<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1, viewport-fit=cover" name="viewport"/>
<meta content="#1b191b" name="theme-color"/>
<meta content="dark" name="color-scheme"/>
<title>Trader Prep</title>
<!-- Icons / Manifest -->
<link href="favicon-32.png" rel="icon" sizes="32x32" type="image/png"/>
<link href="icon-192.png" rel="apple-touch-icon"/>
<link href="manifest.webmanifest" rel="manifest"/>
<!-- Icons (CDN, free) -->
<link crossorigin="" href="https://cdnjs.cloudflare.com" rel="preconnect"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" referrerpolicy="no-referrer" rel="stylesheet"/>
<style>
/* Prevent clipping in auto-refresh dropdown */
#riskQuickTabs .qt-refresh{
  box-sizing:border-box;
  min-width: 140px;
  padding-left: 14px;
  padding-right: 28px; /* space for caret */
  line-height: 1.2;
  overflow: visible;
  text-indent: 0;
}

/* Show only Profit Log and Settings in the header */
.topbar .navicons #nav-prep,
.topbar .navicons #nav-trend,
.topbar .navicons #nav-risk { display:none !important; }

/* Scope quick-switch chips: show only inside #riskQuickTabs */
.qt-chip { display:none !important; }
#riskQuickTabs .qt-chip { display:inline-flex !important; }

/* Show only total on top chips */
.statstrip #chipAKWrap .muted,
.statstrip #chipBGWrap .muted,
.statstrip #chipAK,
.statstrip #chipBG { display:none !important; }
.statstrip #chipAKWrap .tag,
.statstrip #chipBGWrap .tag { margin-right:6px; padding:2px 6px; border-radius:9999px; background:#0002; font-weight:700; }

/* --- Quick Tabs polish --- */
#riskQuickTabs{
  display:flex; flex-wrap:wrap; align-items:center;
  gap:8px; padding:8px 10px; margin:10px 0 12px;
  background:rgba(255,255,255,0.02);
  border:1px solid var(--line);
  border-radius:12px;
}
#riskQuickTabs .tabbtn{
  --h:28px;
  height:var(--h);
  padding:0 12px;
  border-radius:9999px;
  border:1px solid transparent;
  background:#2a2a2f;
  color:var(--fg);
  font-weight:600; font-size:12.5px; letter-spacing:.02em;
  cursor:pointer; user-select:none;
  transition:background .15s ease, transform .06s ease, box-shadow .15s ease;
}
#riskQuickTabs .tabbtn:hover{ background:#34343a; }
#riskQuickTabs .tabbtn:active{ transform:translateY(1px); }
#riskQuickTabs .tabbtn.active{
  background:var(--accent);
  color:#0b0b10;
  box-shadow:0 0 0 2px rgba(120,70,255,.25);
}
#riskQuickTabs .qt-controls{ margin-left:auto; gap:8px; align-items:center; flex-wrap:nowrap }
#riskQuickTabs .qt-add input{ height:28px; border-radius:9999px; padding:0 10px }
#riskQuickTabs .qt-add button,
#riskQuickTabs .qt-clear,
#riskQuickTabs .qt-refresh{ height:28px; border-radius:9999px; padding:0 10px }

/* Clear-selected button: keep text on one line and align with controls */
#riskQuickTabs .qt-controls{display:flex;align-items:center;gap:8px;margin-left:auto;flex-wrap:nowrap}
#riskQuickTabs .qt-clear{
  display:inline-flex; align-items:center; justify-content:center;
  white-space:nowrap; writing-mode:horizontal-tb; text-orientation:mixed; letter-spacing:normal;
  padding:6px 12px; line-height:1; flex:0 0 auto; height:auto;
}

#riskQuickTabs .qt-clear{border-radius:8px;border:1px solid var(--line);background:#2a2a30;padding:6px 8px;cursor:pointer}
#riskQuickTabs .qt-controls{display:flex;align-items:center;gap:8px;margin-left:auto}

/* Candle slider: keep label fixed to the right */
#riskCandlesLabel{position:static !important;left:auto !important;top:auto !important;transform:none !important;margin-left:8px;white-space:nowrap}

/* Fix +Add layout */
#riskQuickTabs .qt-add{display:inline-flex;flex-direction:row;align-items:center;gap:6px}
#riskQuickTabs .qt-add button{writing-mode:horizontal-tb;text-orientation:mixed;transform:none;white-space:nowrap;letter-spacing:normal;padding:6px 10px}
#riskQuickTabs .qt-add input{min-width:64px}

/* Quick Tabs + controls */
#riskQuickTabs{display:flex;gap:10px;margin:8px 0 6px;flex-wrap:wrap;align-items:center}
#riskQuickTabs .tabbtn{border-radius:10px;border:1px solid var(--line);background:#26252b;padding:6px 10px;cursor:pointer;user-select:none}
#riskQuickTabs .tabbtn.active{background:var(--accent);color:#0b0b10;border-color:transparent;font-weight:600}
#riskQuickTabs .tabbtn[draggable="true"]{ -webkit-user-drag:element }
#riskQuickTabs .qt-controls{display:flex;align-items:center;gap:8px;margin-left:auto}
#riskQuickTabs .qt-add{display:inline-flex;gap:6px;align-items:center}
#riskQuickTabs .qt-add input{width:64px;background:#1f1f24;border:1px solid var(--line);border-radius:8px;padding:6px 8px;color:var(--fg);outline:none}
#riskQuickTabs .qt-add button{border-radius:8px;border:1px solid var(--line);background:#2a2a30;padding:6px 8px;cursor:pointer}
#riskQuickTabs .qt-refresh{background:#1f1f24;border:1px solid var(--line);border-radius:8px;padding:6px 8px;color:var(--fg)}

#riskQuickTabs{display:flex;gap:10px;margin:8px 0 2px;flex-wrap:wrap}

#multiSymbolTabs{display:flex !important; gap:10px; margin:8px 0 2px; flex-wrap:wrap;}

    :root {
      --bg:#1b191b; --panel:#2a292f; --panel-2:#242328; --line:#35343a;
      --fg:#f1f2f4; --muted:#a7adbb;
      --accent:#7424ac;           /* main purple */
      --accent-graph:#7c5cff;     /* bright line purple (added) */
      --ok:#6abd74; --bad:#e05d5d; --warn:#d3a54a; --pill:#24252b;
      --shadow:0 6px 18px rgba(0,0,0,.35); --radius:14px; --pad:16px;
    }
    html,body{background:var(--bg);color:var(--fg)}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica Neue,Arial,sans-serif;margin:0;line-height:1.35;word-break:break-word}
    a{color:inherit}

    /* Top bar */
    .topbar{position:sticky;top:0;z-index:50;display:flex;align-items:center;justify-content:space-between;background:linear-gradient(180deg,#201f25 0%,#1a191f 100%);border-bottom:1px solid var(--line);padding:10px 14px}
    .brand{display:flex;gap:10px;align-items:center;min-width:0}
    .brand .logo{width:36px;height:36px;display:grid;place-items:center;border-radius:10px;background:#2f2e36;border:1px solid var(--line);overflow:hidden;flex:0 0 auto}
    .brand h1{font-size:16px;margin:0;letter-spacing:.3px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .navicons{display:flex;gap:10px;align-items:center}
    .iconbtn{min-width:44px;min-height:44px;display:grid;place-items:center;border-radius:12px;border:1px solid var(--line);background:#26252b;cursor:pointer;color:#cfd3dc}
    .iconbtn.active{background:var(--accent);color:#090909;border-color:transparent}

    /* Stat strip */
    .statstrip{display:flex;gap:10px;align-items:center;padding:10px 14px;flex-wrap:wrap;border-bottom:1px solid var(--line);background:#1e1d22}
    .chip{display:flex;gap:8px;align-items:center;padding:6px 10px;background:#2a2930;border:1px solid var(--line);border-radius:10px;font-size:12px}
    .chip.ok{background:#213224;color:var(--ok);border-color:#2a4930}
    .chip.warn{background:#332d1f;color:var(--warn);border-color:#5a4726}
    .chip.bad{background:#372325;color:var(--bad);border-color:#5d3439}

    /* Shell */
    .wrap{max-width:1100px;margin:0 auto;padding:14px}
    .card{background:var(--panel);border:1px solid var(--line);border-radius:var(--radius);padding:var(--pad);box-shadow:var(--shadow);margin:14px 0}
    .muted{color:var(--muted)}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .actions{display:flex;gap:10px;flex-wrap:wrap}
    button,select,input{font-size:15px}
    select,input{background:var(--panel-2);color:var(--fg);border:1px solid var(--line);border-radius:12px;padding:12px 12px;width:100%}
    button{padding:12px 16px;border-radius:12px;border:1px solid var(--line);background:var(--panel-2);color:var(--fg);cursor:pointer}
    .primary{background:var(--accent);color:#0b0b10;border-color:transparent;font-weight:600}
    .tabs{display:flex;gap:10px;margin:8px 0 2px;flex-wrap:wrap}
    .tabbtn{border-radius:10px;border:1px solid var(--line);background:#26252b;padding:8px 12px;cursor:pointer}
    .tabbtn.active{background:var(--accent);color:#0b0b10;border-color:transparent}
    .pill{display:inline-flex;gap:8px;align-items:center;padding:6px 12px;border-radius:999px;background:var(--pill);border:1px solid var(--line);font-size:13px;white-space:nowrap;line-height:1.1}
    .pill.accent{background:var(--accent);color:#0b0b10;border-color:transparent}
    .ok{color:var(--ok)} .warn{color:var(--warn)} .bad{color:var(--bad)}
    details summary{cursor:pointer}
    .bundles{display:flex;flex-wrap:wrap;gap:8px;margin-top:8px}
    .bundle{padding:6px 10px;border-radius:10px;border:1px solid var(--line);background:#26252b;font-size:14px;cursor:pointer}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media (max-width:900px){.grid{grid-template-columns:1fr}}

    /* Chart canvas */
    .chart{width:100%;height:190px;border-radius:10px;background:#24252b;margin-top:10px;display:block}
    .legend{display:flex;flex-wrap:wrap;gap:10px;align-items:center;margin-top:8px;font-size:12px;color:var(--muted)}
    .legend .item{display:inline-flex;gap:8px;align-items:center;padding:6px 10px;border-radius:10px;border:1px solid var(--line);background:#26252b}
    .swatch{display:inline-block;width:20px;height:10px;border-radius:2px}
    .swatch.line{width:28px;height:0;border-top:3px solid currentColor}
    .swatch.dashed{border-top-style:dashed}

    .seg{display:flex;gap:8px;flex-wrap:wrap}
    .segbtn{padding:8px 12px;border:1px solid var(--line);background:#26252b;border-radius:10px;cursor:pointer}
    .segbtn.active{background:var(--accent);color:#0b0b10;border-color:transparent}
    .spinner{display:inline-block;width:18px;height:18px;border:3px solid #45434c;border-top-color:#ddd;border-radius:50%;animation:spin 1s linear infinite;vertical-align:-3px}
    @keyframes spin{to{transform:rotate(360deg)}}
    .flash{animation:flash .6s ease}@keyframes flash{0%{color:var(--ok)}100%{color:var(--muted)}}
    .sliderrow{display:flex;align-items:center;gap:10px;position:relative}
    .sliderrow input[type=range]{width:200px}
    /* Position the candles label over the slider knob.  We use absolute
       positioning so the pill follows the knob as the user moves the
       slider.  The JS below computes the left offset based on the
       current slider value. */
    #riskCandlesLabel{white-space:nowrap;
  position:absolute;
  top:-26px;
  transform:translateX(-50%);
  pointer-events:none;
}

   /* Mobile tweaks */
@media (max-width:520px){
  .brand h1{font-size:14px}
  .chip{font-size:11px}
  .tabbtn,button{padding:10px 12px}
  .legend{font-size:11px}

  .statstrip{overflow-x:auto;flex-wrap:nowrap}
  .statstrip::-webkit-scrollbar{display:none}
  .chip{flex:0 0 auto}
  .navicons{gap:8px}

  /* Make pills smaller on mobile (optional: keep this scoped only to Risk) */
  #riskAdvice .pill,
  #riskSummary .pill {
    font-size: 11px;       /* desktop is 13px */
    padding: 4px 8px;
    max-width: 100%;
    box-sizing: border-box;

    /* Let pills wrap instead of overflowing on small screens */
    white-space: normal;    /* overrides base .pill nowrap */
    word-break: break-word; /* split long tickers/words if needed */
    display: block;         /* occupy full line for nicer wrapping */
    line-height: 1.2;
  }
}

    /* Marquee / auto-scroll helpers */
    .autoscroll{display:block; overflow:hidden; max-width:100%; box-sizing:border-box; border-radius:999px;}
    @media (max-width:520px){
      .autoscroll .track{display:inline-block; white-space:nowrap; will-change:transform; animation:marquee var(--dur,12s) linear infinite;}
    }
    @keyframes marquee{0%{transform:translateX(0)}100%{transform:translateX(-50%)}}

  </style>
<style id="risk-tabs-qol-css">
/* Risk tabs QoL */
#riskTabBar{ display:flex; gap:6px; flex-wrap:wrap; margin:8px 8px 10px; align-items:center; }
#riskTabBar .rtab{ font-size:12px; padding:5px 10px; border-radius:10px; border:1px solid #333; background:#1c1c1f; color:#e9e9ea; display:inline-flex; gap:8px; align-items:center; cursor:pointer; user-select:none; }
#riskTabBar .rtab.active{ background:#2b2b30; border-color:#555; }
#riskTabBar .rtab.pinned{ border-color:#777; box-shadow:inset 0 0 0 1px #555; }
#riskTabBar .rtab .close{ opacity:.7; cursor:pointer; font-weight:700; }
#riskTabBar .rtab .pin{ opacity:.8; font-size:12px; line-height:1; cursor:pointer; }
#riskTabBar .rtab[draggable="true"]{ -webkit-user-drag:element; }
#riskTabBar .spacer{ flex:1 1 auto; }
#riskTabBar .menuBtn{ background:transparent; border:1px solid #333; color:#e9e9ea; border-radius:10px; font-size:12px; padding:4px 8px; cursor:pointer; }
#riskContext{ position:fixed; z-index:99999; min-width:160px; background:#1c1c1f; color:#fff; border:1px solid #333; border-radius:8px; box-shadow:0 8px 24px rgba(0,0,0,.35); display:none; }
#riskContext .mi{ padding:8px 12px; cursor:pointer; white-space:nowrap; }
#riskContext .mi:hover{ background:#2b2b30; }
#riskContext hr{ border:0; border-top:1px solid #2b2b2f; margin:6px 0; }
.risk-shimmer{ position:relative; overflow:hidden; background:linear-gradient(90deg, rgba(255,255,255,0.04) 25%, rgba(255,255,255,0.08) 37%, rgba(255,255,255,0.04) 63%); background-size:400% 100%; animation:shimmer 1.1s infinite; border-radius:12px; min-height:160px; }
@keyframes shimmer{ 0%{background-position:100% 0} 100%{background-position:0 0} }
</style></head>
<body>
<!-- HEADER -->
<header class="topbar">
<div class="brand">
<div class="logo"><img alt="Trader Prep Logo" src="icon-192.png" style="width:100%;height:100%;object-fit:contain"/></div>
<h1>Trader Prep</h1>
</div>
<nav class="navicons">
<div class="iconbtn active" id="nav-prep" title="Prep"><i class="fa-solid fa-bars-staggered"></i></div>
<div class="iconbtn" id="nav-trend" title="Trend"><i class="fa-solid fa-wave-square"></i></div>
<div class="iconbtn" id="nav-risk" title="Risk"><i class="fa-solid fa-fire-flame-curved"></i></div>
<div class="iconbtn" id="nav-pnl" title="Profit Log"><i class="fa-solid fa-dollar-sign"></i></div>
<div class="iconbtn" id="nav-settings" title="Settings"><i class="fa-solid fa-gear"></i></div>
</nav>
</header>
<!-- STATS -->
<div class="statstrip">
<div class="chip" id="chipAKWrap"><span class="muted">AK$ (today):</span> <strong id="chipAK">$0.00</strong><span class="muted" style="margin-left:8px">/ all:</span> <span class="pill" id="chipAKAllWrap"><span class="tag">AK</span> <strong id="chipAKAll">$0.00</strong></span></div>
<div class="chip" id="chipBGWrap"><span class="muted">BG$ (today):</span> <strong id="chipBG">$0.00</strong><span class="muted" style="margin-left:8px">/ all:</span> <span class="pill" id="chipBGAllWrap"><span class="tag">BG</span> <strong id="chipBGAll">$0.00</strong></span></div>
<div class="chip ok" id="conn1"><i class="fa-solid fa-signal"></i> API OK</div>
<div class="chip ok" id="conn2"><i class="fa-solid fa-chart-line"></i> Data OK</div>
</div>
<div class="wrap">
<!-- SETTINGS -->
<div class="card" id="panel-settings" style="display:none">
<div class="row"><strong>Settings</strong><span class="muted">(Keys optional; proxy fallback built-in)</span></div>
<div class="row" style="margin-top:10px"><label class="muted" style="min-width:170px">Custom Proxy</label><input id="customProxy" placeholder="https://script.google.com/macros/s/.../exec?url="/></div>
<div class="row" style="margin-top:10px"><label class="muted" style="min-width:170px">GNews API Key</label><input id="gnews" placeholder="gnews.io token"/></div>
<div class="row" style="margin-top:10px"><label class="muted" style="min-width:170px">Alpha Vantage Key</label><input id="alpha" placeholder="alphavantage.co key"/></div>
<div class="actions" style="margin-top:10px"><button class="primary" id="saveKeys"><i class="fa-regular fa-floppy-disk"></i> Save Keys</button><button id="testFetch"><i class="fa-solid fa-vial"></i> Test Data Fetch</button><span class="muted" id="saveMsg"></span></div>
<div class="muted" id="diag" style="margin-top:8px;font-size:13px"></div>
</div>
<!-- PNL -->
<div class="card" id="panel-pnl" style="display:none">
<div class="row"><strong>Daily P&amp;L Log</strong><span class="muted">(updates AK$/BG$ chips for today)</span></div>
<div class="row" style="margin-top:10px"><label class="muted" style="min-width:170px">Who</label><div class="actions"><label><input checked="" name="who" type="radio" value="AK"/> AK</label><label style="margin-left:10px"><input name="who" type="radio" value="BG"/> BG</label></div></div>
<div class="row" style="margin-top:10px"><label class="muted" style="min-width:170px">Amount ($)</label><input id="pnlAmount" placeholder="e.g. 125.50 or -75"/></div>
<div class="row" style="margin-top:10px"><label class="muted" style="min-width:170px">Note (optional)</label><input id="pnlNote" placeholder="scalp NQ open, etc."/></div>
<div class="actions" style="margin-top:10px"><button class="primary" id="logPnl"><i class="fa-solid fa-plus"></i> Log Profit</button><span class="muted" id="pnlMsg"></span></div>
</div>
<div id="multiSymbolTabs" class="tabs" aria-label="Open symbols"></div>
<!-- MARKET PICKER -->
<div class="card">
<!-- Hide the Prep/Trend/Risk tabs row; navigation is handled via the top bar -->
<div class="tabs" style="display:none">
<button class="tabbtn active" id="tab-prep">Prep</button>
<button class="tabbtn" id="tab-trend">Trend</button>
<button class="tabbtn" id="tab-risk">Risk</button>
</div>
<strong>Choose your markets</strong>
<div class="bundles">
<button class="bundle" data-bundle="ES,NQ,YM,RTY">US Indices</button>
<button class="bundle" data-bundle="CL,GC">Energy &amp; Gold</button>
<button class="bundle" data-bundle="ZN,6E">Rates / FX</button>
</div>
<div class="grid" style="margin-top:10px">
<div>
<label class="muted">Futures/markets</label>
<select aria-label="Futures and markets" id="futures" multiple="" size="8">
<option value="ES">ES – S&amp;P 500</option>
<option value="NQ">NQ – Nasdaq 100</option>
<option value="YM">YM – Dow</option>
<option value="RTY">RTY – Russell 2000</option>
<option value="CL">CL – Crude Oil</option>
<option value="GC">GC – Gold</option>
<option value="ZN">ZN – 10-Yr Note</option>
<option value="6E">6E – EUR/USD</option>
</select>
</div>
<div>
<div class="muted">Trend/Risk timeframe</div>
<div class="seg" style="margin-top:6px">
<button class="segbtn active" data-tf="15">15m</button>
<button class="segbtn" data-tf="30">30m</button>
<button class="segbtn" data-tf="60">60m</button>
</div>
<div class="muted" style="margin-top:6px">Trend/Risk use 1-minute Yahoo bars (via your proxy), mapped futures → ETFs.</div>
</div>
</div>
<div class="actions" style="margin-top:12px">
<button class="primary" id="start"><i class="fa-solid fa-bolt"></i> Analyze (Prep)</button>
<button class="primary" id="runTrend"><i class="fa-solid fa-wave-square"></i> Analyze (Trend)</button>
<button class="primary" id="runRisk"><i class="fa-solid fa-fire-flame-curved"></i> Analyze (Risk)</button>
</div>
</div>
<!-- PREP -->
<div class="card" id="prepOut">
<div class="row"><strong>Trader Prep</strong><span class="muted">Now: <span id="now"></span></span></div>
<div class="muted">Focus: <span id="focus"></span> • <span id="keyStatus"></span></div>
<div id="summary" style="margin-top:12px"></div>
<h3 style="margin-top:16px">Quick Links</h3>
<ul id="links"></ul>
</div>
<!-- TREND -->
<div class="card" id="trendOut" style="display:none">
<div class="row"><strong>Current Trend</strong><span class="muted">Window: <span id="trendWin">15m</span></span></div>
<div class="muted">Primary: <span id="trendSym"></span> (mapped ETF) • <span id="trendTime"></span></div>
<div id="trendSummary" style="margin-top:12px"></div>
<canvas class="chart" id="trendChart"></canvas>
<div class="legend" id="trendLegend"></div>
<div id="trendAdvice" style="margin-top:12px"></div>
<div class="muted" style="margin-top:6px;font-size:12px">Last refreshed: <span id="trendRef">—</span></div>
<details style="margin-top:10px"><summary>How we decide “busy”</summary>
<div class="muted" style="margin-top:6px">We compute 1-minute returns and flag as <b>Busy</b> when realized vol in the window is elevated (≥ ~0.06% std-dev) or average volume is above the window’s median (≥ 1.2×).</div>
</details>
</div>
<!-- RISK -->
<div class="card" id="riskQuickTabs" class="tabs" aria-label="Quick switch between selected symbols"></div>
<div id="riskOut" style="display:none">
<div class="row"><strong>Risk Read</strong><span class="muted">Window: <span id="riskWin">15m</span></span></div>
<div class="seg" id="riskModeSeg" style="margin:6px 0 2px">
<button class="segbtn active" data-mode="conservative">Conservative</button>
<button class="segbtn" data-mode="aggressive">Aggressive</button>
<!-- The candles count pill is no longer displayed next to the mode buttons; it will appear next to the slider instead -->
</div>
<div class="sliderrow" style="margin:4px 0 8px">
<!-- Candles label and slider: show the candles count pill directly to the left of the slider -->
<span class="muted" style="min-width:120px">Candles (1m each)</span>
<span class="pill" id="riskCandlesLabel" style="margin-left:0">3 candles</span>
<input aria-label="Risk candles" id="riskCandles" max="15" min="3" step="1" type="range" value="3"/>
</div>
<div class="muted">Primary: <span id="riskSym"></span> (mapped ETF) • <span id="riskTime"></span></div>
<div id="riskSummary" style="margin-top:12px"></div>
<canvas class="chart" id="riskChart"></canvas>
<div class="legend" id="riskLegend"></div>
<div id="riskAdvice" style="margin-top:12px"></div>
<div class="muted" style="margin-top:6px;font-size:12px">Last refreshed: <span id="riskRef">—</span></div>
</div>
</div>
<script>
    /* ---------------- Config ---------------- */
    const PROXY_RAW = 'https://script.google.com/macros/s/AKfycbztzwYcRxD3mQ2MgD99ubT3-nW-nQJiU-thNoUrdRuMkrTIF1LilnEyCbysHP6Z7HYf/exec?url=';

    // ===== PnL API =====
    const PNL_API = 'https://script.google.com/macros/s/AKfycbxlUD8DcZ-yFA7Hc-A-_ZnRlm4HfqGVoybR-os4Y2hCAzVIE8Tfn9XDd3pMDspWmvTE/exec'; // <-- no ?url=
    const PNL_TOKEN = 'mWkV1zQ3WMVsoKKYXk2GJHOILSBIgPCK3KWCTsW4PLvV5i8M';

    /* ---- Custom Proxy + Fallbacks ---- */
    function getCustomProxy(){ return (localStorage.getItem('CUSTOM_PROXY')||'').trim(); }
    const PROXIES = [
      () => (PROXY_RAW || '').trim(),  // your hardcoded Apps Script
      () => getCustomProxy(),          // user-provided Apps Script
      'https://api.allorigins.win/raw?url=' // public fallback
    ];
    function wrapUrl(u, idx){
      const p = PROXIES[idx];
      const v = (typeof p === 'function') ? p() : p;
      if(!v) return null;
      if(v.endsWith('?url=') || v.endsWith('%3Furl%3D')) return v + encodeURIComponent(u);
      return v + encodeURIComponent(u);
    }
    async function fetchWithFallback(url, type='json', timeout=10000){
      let lastErr=null, used='';
      for(let i=0;i<PROXIES.length;i++){
        const wrapped = wrapUrl(url, i);
        if(!wrapped) continue;
        try{
          const c = new AbortController(); const to = setTimeout(()=>c.abort('timeout'), timeout);
          const res = await fetch(wrapped, {signal:c.signal, cache:'no-store'});
          clearTimeout(to);
          if(!res.ok) throw new Error('HTTP '+res.status);
          used = (typeof PROXIES[i] === 'function') ? (PROXIES[i]===PROXIES[0]?'PROXY_RAW':'customProxy') : 'allorigins';
          const data = type==='json' ? await res.json() : await res.text();
          return {ok:true, used, data};
        }catch(e){ lastErr=e; }
      }
      return {ok:false, error:String(lastErr||'unknown'), used};
    }

    // Settings load/save + Test button
    const customProxyEl = document.getElementById('customProxy');
    const testBtn = document.getElementById('testFetch');
    const diagEl = document.getElementById('diag');
    (function setupSettings(){
      if(customProxyEl){ customProxyEl.value = getCustomProxy(); }
      const save = document.getElementById('saveKeys');
      if(save){
        save.addEventListener('click', ()=>{
          localStorage.setItem('GNEWS_KEY', (document.getElementById('gnews')||{}).value?.trim()||'');
          localStorage.setItem('ALPHA_KEY', (document.getElementById('alpha')||{}).value?.trim()||'');
          if(customProxyEl) localStorage.setItem('CUSTOM_PROXY', customProxyEl.value.trim());
          const sm=document.getElementById('saveMsg'); if(sm){ sm.textContent='Saved ✓'; setTimeout(()=>sm.textContent='',1200); }
        });
      }
      if(testBtn){
        testBtn.addEventListener('click', async()=>{
          if(diagEl) diagEl.textContent = 'Testing Yahoo 1m via fallbacks...';
          const url='https://query1.finance.yahoo.com/v8/finance/chart/SPY?range=1d&interval=1m&includePrePost=true';
          const r = await fetchWithFallback(url,'json',10000);
          if(r.ok){
            if(diagEl) diagEl.innerHTML = `<span class="chip ok">OK via <b>${r.used}</b></span>`;
            const c2=document.getElementById('conn2'); if(c2){ c2.className='chip ok'; c2.innerHTML='<i class="fa-solid fa-chart-line"></i> Data OK'; }
          }else{
            if(diagEl) diagEl.innerHTML = `<span class="chip bad">Failed: ${r.error}</span> • Try a Custom Proxy (Apps Script).`;
            const c2=document.getElementById('conn2'); if(c2){ c2.className='chip bad'; c2.innerHTML='<i class="fa-solid fa-chart-line"></i> Data FAIL'; }
          }
        });
      }
    })();


    /* ---------------- Nav / Tabs ---------------- */
    const panelSettings=document.getElementById('panel-settings');
    const panelPnL=document.getElementById('panel-pnl');
    const navPrep=document.getElementById('nav-prep'),navTrend=document.getElementById('nav-trend'),navSettings=document.getElementById('nav-settings'),navPnL=document.getElementById('nav-pnl'),navRisk=document.getElementById('nav-risk');

    function hidePanels(){panelSettings.style.display='none';panelPnL.style.display='none'}
    function setNav(active){
      [navPrep,navTrend,navSettings,navPnL,navRisk].forEach(n=>n.classList.toggle('active',n.id===active));
      hidePanels();
      if(active==='nav-settings') panelSettings.style.display='block';
      if(active==='nav-pnl') panelPnL.style.display='block';
      if(active==='nav-prep') setTab('prep');
      if(active==='nav-trend') setTab('trend');
      if(active==='nav-risk') setTab('risk');
    }
    navPrep.onclick=()=>setNav('nav-prep'); navTrend.onclick=()=>setNav('nav-trend'); navSettings.onclick=()=>setNav('nav-settings'); navPnL.onclick=()=>setNav('nav-pnl'); navRisk.onclick=()=>setNav('nav-risk');

    const tabPrep=document.getElementById('tab-prep'), tabTrend=document.getElementById('tab-trend'), tabRisk=document.getElementById('tab-risk');
    const prepOut=document.getElementById('prepOut'), trendOut=document.getElementById('trendOut'), riskOut=document.getElementById('riskOut');
    function setTab(which){
      tabPrep.classList.toggle('active',which==='prep');
      tabTrend.classList.toggle('active',which==='trend');
      tabRisk.classList.toggle('active',which==='risk');
      prepOut.style.display=(which==='prep')?'':'none';
      trendOut.style.display=(which==='trend')?'':'none';
      riskOut.style.display=(which==='risk')?'':'none';
    }

    /* ---------------- Elements ---------------- */
    const futuresSel=document.getElementById('futures');
    const startBtn=document.getElementById('start'), runTrendBtn=document.getElementById('runTrend'), runRiskBtn=document.getElementById('runRisk');
    const nowEl=document.getElementById('now'), focusEl=document.getElementById('focus'), summaryEl=document.getElementById('summary'), linksEl=document.getElementById('links');
    const keyStatusEl=document.getElementById('keyStatus'), gnewsEl=document.getElementById('gnews'), alphaEl=document.getElementById('alpha');
    const saveBtn=document.getElementById('saveKeys'), saveMsg=document.getElementById('saveMsg');

    const trendWinEl=document.getElementById('trendWin'), trendSymEl=document.getElementById('trendSym'), trendTimeEl=document.getElementById('trendTime'), trendSummaryEl=document.getElementById('trendSummary'), trendAdviceEl=document.getElementById('trendAdvice'), trendCanvas=document.getElementById('trendChart');
    const riskWinEl=document.getElementById('riskWin'), riskSymEl=document.getElementById('riskSym'), riskTimeEl=document.getElementById('riskTime'), riskSummaryEl=document.getElementById('riskSummary'), riskAdviceEl=document.getElementById('riskAdvice'), riskCanvas=document.getElementById('riskChart');
    const trendLegend=document.getElementById('trendLegend');
    const riskLegend=document.getElementById('riskLegend');

    /* ---------------- Timeframe ---------------- */
    let trendMinutes=15;
    const segBtns=document.querySelectorAll('.segbtn[data-tf]');
    function setTfActive(mins){
      segBtns.forEach(btn=>btn.classList.toggle('active',parseInt(btn.dataset.tf,10)===mins));
      trendMinutes=mins; trendWinEl.textContent=mins+'m'; riskWinEl.textContent=mins+'m';
    }
    segBtns.forEach(btn=>btn.addEventListener('click',()=>setTfActive(parseInt(btn.dataset.tf,10))));

    /* ---------------- Keys ---------------- */
    function loadKeys(){gnewsEl.value=localStorage.getItem('GNEWS_KEY')||'';alphaEl.value=localStorage.getItem('ALPHA_KEY')||''}
    function saveKeys(){localStorage.setItem('GNEWS_KEY',gnewsEl.value.trim());localStorage.setItem('ALPHA_KEY',alphaEl.value.trim());saveMsg.textContent='Saved ✓';setTimeout(()=>saveMsg.textContent='',1500)}
    if(saveBtn){loadKeys(); saveBtn.addEventListener('click',saveKeys);}

    /* ---------------- Futures helpers ---------------- */
    function getSelectedFutures(){return Array.from(futuresSel.selectedOptions).map(o=>o.value)}
    document.querySelectorAll('.bundle[data-bundle]').forEach(b=>b.addEventListener('click',()=>{const arr=b.dataset.bundle.split(',');for(const o of futuresSel.options)o.selected=arr.includes(o.value)}));

    function showPrepHeader(markets){nowEl.textContent=new Date().toLocaleString();focusEl.textContent=markets.join(', ')}
    function makeLinks(markets){const q=encodeURIComponent(markets.join(' ')||'ES NQ');linksEl.innerHTML=`<li><a target="_blank" href="https://www.google.com/search?q=index+futures">Index Futures Snapshot</a></li><li><a target="_blank" href="https://www.google.com/search?q=today+economic+calendar">Economic Calendar</a></li><li><a target="_blank" href="https://news.google.com/">Macro headlines</a></li><li><a target="_blank" href="https://news.google.com/search?q=${q}">News for ${markets.join(', ')}</a></li>`}

    /* ---------------- Maps ---------------- */
    const FUTURES_TO_ETF={ES:'SPY',NQ:'QQQ',YM:'DIA',RTY:'IWM',CL:'USO',GC:'GLD',ZN:'IEF','6E':'FXE'};
    const ETF_TO_STOOQ={SPY:'spy.us',QQQ:'qqq.us',DIA:'dia.us',IWM:'iwm.us',USO:'uso.us',GLD:'gld.us',IEF:'ief.us',FXE:'fxe.us'};

    /* ---------------- Sentiment rules ---------------- */
    const POS=['beat','surge','strong','record','optim','rally','up','gain','bull','expand','growth'];
    const NEG=['miss','fall','weak','cut','warn','down','bear','slump','contract','decline','risk','halt','ban','tariff'];
    function headlineScore(t){const s=t.toLowerCase();let n=0;POS.forEach(w=>{if(s.includes(w))n++});NEG.forEach(w=>{if(s.includes(w))n--});return n}
    function overallLabel(score){if(score>=2)return['Bullish','ok'];if(score<=-2)return['Bearish','bad'];return['Neutral','warn']}

    const CAUSE_RULES=[
      {key:'fed',label:'Fed/Rate outlook',pat:/(fed|powell|fomc|rate cut|rate hike|yield|treasury|dot plot|t-bill|t-note|t-bond)/i,w:2},
      {key:'cpi',label:'Inflation (CPI/PCE)',pat:/(cpi|pce|inflation|core inflation|ppi)/i,w:2},
      {key:'jobs',label:'Labor data',pat:/(nonfarm|nfp|payrolls|unemployment|jobless|initial claims|jolts)/i,w:2},
      {key:'gdp',label:'Growth data',pat:/(gdp|growth|pmis?)/i,w:1},
      {key:'earnings',label:'Earnings',pat:/(earnings|eps|revenue|guidance|beats?|miss(es)?|outlook|forecast)/i,w:2},
      {key:'mega',label:'Mega-cap tech',pat:/(apple|aapl|microsoft|msft|amazon|amzn|google|alphabet|googl|meta|fb|nvidia|nvda|tsla)/i,w:2},
      {key:'china',label:'China',pat:/(china|beijing|shanghai|pboc|property crisis|evergrande)/i,w:1},
      {key:'geopol',label:'Geopolitics',pat:/(war|missile|strike|conflict|israel|ukraine|taiwan|sanction|tariff|houthis?)/i,w:2},
      {key:'oil',label:'Oil/Energy',pat:/(oil|brent|wti|opec|opec\+|gasoline|refinery|energy prices?)/i,w:1},
      {key:'banks',label:'Banks/Credit',pat:/(bank(s)?|credit|default|downgrade|upgrade|capital|liquidity|stress test)/i,w:1},
      {key:'crypto',label:'Crypto',pat:/(bitcoin|btc|ethereum|eth|crypto|spot etf)/i,w:1},
      {key:'reg',label:'Regulation/Policy',pat:/(regulat(e|ion)|antitrust|probe|ftc|doj|ec|ban|export controls?)/i,w:1}
    ];
    const WHY_PCT=0.35;

    function topCausesFromHeadlines(headlines,max=3){
      const scores=new Map();const examples={};
      for(const h of (headlines||[])){for(const r of CAUSE_RULES){if(r.pat.test(h)){scores.set(r.key,(scores.get(r.key)||0)+r.w);if(!examples[r.key])examples[r.key]=h}}}
      return Array.from(scores.entries()).sort((a,b)=>b[1]-a[1]).slice(0,max).map(([key,score])=>({key,score,label:CAUSE_RULES.find(rr=>rr.key===key).label,sample:examples[key]}))
    }
    function moveDescriptor(pct){const ap=Math.abs(pct);if(ap>=2)return'surging';if(ap>=1)return'up solidly';if(ap>=0.5)return'firm';if(ap>=0.2)return'slightly higher';return'little changed'}
    function buildWhyNarrative({dayRes,headlines}){const parts=[];if(dayRes?.ok){const dir=dayRes.pct>=0?'higher':'lower',tone=moveDescriptor(dayRes.pct);parts.push(`Markets are ${tone} (${dayRes.pct.toFixed(2)}% ${dir} for ${dayRes.etf} at the last close).`)}const causes=topCausesFromHeadlines(headlines,3);if(causes.length){parts.push(`Likely drivers: ${causes.map(c=>c.label).join(', ')}.`);const s=causes[0].sample;if(s)parts.push(`e.g., “${s.replace(/"/g,'')}”.`)}else parts.push(`No dominant driver detected; tone appears mixed.`);return parts.join(' ')}

    /* ---------------- Fetch helpers ---------------- */
    async function fetchJsonOnce(u,t=9000){const c=new AbortController();const to=setTimeout(()=>c.abort('timeout'),t);try{const r=await fetch(u,{signal:c.signal,cache:'no-store'});if(!r.ok)throw new Error('HTTP '+r.status);return await r.json()}finally{clearTimeout(to)}}
    async function fetchJsonRetry(u,tries=2){let e=null;for(let i=0;i<tries;i++){try{return await fetchJsonOnce(u,i?12000:9000)}catch(x){e=x;await new Promise(r=>setTimeout(r,300))}}throw e}
    async function fetchTextOnce(u,t=9000){const c=new AbortController();const to=setTimeout(()=>c.abort('timeout'),t);try{const r=await fetch(u,{signal:c.signal,cache:'no-store'});if(!r.ok)throw new Error('HTTP '+r.status);return await r.text()}finally{clearTimeout(to)}}
    async function fetchTextRetry(u,tries=2){let e=null;for(let i=0;i<tries;i++){try{return await fetchTextOnce(u,i?12000:9000)}catch(x){e=x;await new Promise(r=>setTimeout(r,300))}}throw e}

    /* ---------------- Headlines ---------------- */
    async function getHeadlines(markets){
      const gkey=(localStorage.getItem('GNEWS_KEY')||'').trim();
      if(gkey){try{const q=encodeURIComponent(markets.join(' OR '));const url=`https://gnews.io/api/v4/search?q=${q}&lang=en&country=us&max=20&token=${gkey}`;const data=await fetchJsonRetry(url,2);const headlines=(data.articles||[]).map(a=>a.title||'').filter(Boolean);return {ok:true,source:'gnews',headlines}}catch(e){}}
      const q=encodeURIComponent(markets.join(' '));const rss=`https://news.google.com/rss/search?q=${q}&hl=en-US&gl=US&ceid=US:en&t=${Date.now()}`;
      try{const xml=await fetchTextRetry(PROXY_RAW+encodeURIComponent(rss),2);const doc=new DOMParser().parseFromString(xml,'text/xml');const items=Array.from(doc.querySelectorAll('item>title'));const heads=items.map(n=>n.textContent||'').filter(Boolean);return {ok:heads.length>0,source:'rss-proxy',headlines:heads}}catch(e){return {ok:false,source:'rss-proxy',reason:String(e)}}}

    /* ---------------- Last day (Alpha→Yahoo→Stooq) ---------------- */
    async function getLastDayMove(markets){
      const akey=(localStorage.getItem('ALPHA_KEY')||'').trim();
      const etf=FUTURES_TO_ETF[markets[0]||'ES']||'SPY';
      if(akey){try{const url=`https://www.alphavantage.co/query?function=TIME_SERIES_DAILY&symbol=${etf}&apikey=${akey}`;const data=await fetchJsonRetry(url,2);const s=data['Time Series (Daily)']||{};const d=Object.keys(s).sort().reverse();if(d.length>=2){const c0=parseFloat(s[d[0]]['4. close']), c1=parseFloat(s[d[1]]['4. close']);const pct=((c0-c1)/c1)*100, delta=c0-c1;const closes=d.slice(0,10).reverse().map(k=>parseFloat(s[k]['4. close'])).filter(n=>isFinite(n));return {ok:true,etf,latest:d[0],prior:d[1],pct,delta,closes,source:'alpha'}}}catch(e){}}
      try{const yUrl=`https://query1.finance.yahoo.com/v8/finance/chart/${encodeURIComponent(etf)}?range=15d&interval=1d&t=${Date.now()}`;const yData=await fetchJsonRetry(PROXY_RAW+encodeURIComponent(yUrl)+'&cb='+Date.now(),2);const r=yData?.chart?.result?.[0];const closes=r?.indicators?.quote?.[0]?.close?.filter(v=>v!=null)||[];if(closes.length>=2){const c0=closes.at(-1), c1=closes.at(-2);const pct=((c0-c1)/c1)*100, delta=c0-c1;const ts=r.timestamp||[];const toDate=t=>{const d=new Date(t*1000);return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`};const latest=ts.length?toDate(ts.at(-1)):'', prior=ts.length>1?toDate(ts.at(-2)):'';return {ok:true,etf,latest,prior,pct,delta,closes:closes.slice(-10),source:'yahoo-proxy'}}}catch(e){}
      const sym=ETF_TO_STOOQ[etf]||'spy.us';const srcs=[`https://stooq.com/q/d/l/?s=${encodeURIComponent(sym)}&i=d&t=${Date.now()}`,`https://stooq.pl/q/d/l/?s=${encodeURIComponent(sym)}&i=d&t=${Date.now()}`];
      let lastErr=null;for(const u of srcs){try{const csv=await fetchTextRetry(PROXY_RAW+encodeURIComponent(u),2);const rows=csv.trim().split('\n');if(rows.length>=3){const last=rows.at(-1).split(','), prev=rows.at(-2).split(',');const c0=parseFloat(last[4]), c1=parseFloat(prev[4]);if(!isFinite(c0)||!isFinite(c1)) throw new Error('bad close');const pct=((c0-c1)/c1)*100, delta=c0-c1;const closes=rows.slice(-11).slice(1).map(r=>parseFloat(r.split(',')[4])).filter(v=>isFinite(v));return {ok:true,etf,latest:last[0],prior:prev[0],pct,delta,closes,source:u.includes('.pl')?'stooq-proxy(pl)':'stooq-proxy(com)'}}}catch(e){lastErr=e}}return {ok:false,reason:String(lastErr||'fetch failed')}}
    function sentimentFrom(h){const total=h.reduce((a,t)=>a+headlineScore(t),0);const [label,cls]=overallLabel(total);return {label,cls,total}}
    function drawSparkline(container,values){if(!values||values.length<2)return;const c=document.createElement('canvas');c.className='chart';container.appendChild(c);drawLineChart(c,values.map((v,i)=>({c:v,t:i})))}

    /* ---------------- Charts ---------------- */

    function quantile(arr, q){
      if(!arr || !arr.length) return NaN;
      const a=[...arr].sort((x,y)=>x-y); 
      const pos=(a.length-1)*q;
      const base=Math.floor(pos), rest=pos-base;
      if(a[base+1]!==undefined) return a[base]+rest*(a[base+1]-a[base]);
      return a[base];
    }

    function sizeCanvas(canvas){
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const cssW = canvas.clientWidth || 700;
      const cssH = canvas.clientHeight || 190;
      canvas.width = Math.floor(cssW * dpr);
      canvas.height = Math.floor(cssH * dpr);
      return { ctx: canvas.getContext('2d'), w: canvas.width, h: canvas.height, dpr };
    }


      function drawCandleChart(canvas, bars, opts = {}) {
  const progressLast = Math.max(0, Math.min(1, Number(opts.progressFracLast || 1)));
  const robustZoom = opts.robustZoom !== false;

  // MUST get ctx,w,h before we can draw anything
  const { ctx, w, h } = sizeCanvas(canvas);        // ← required first
  ctx.clearRect(0, 0, w, h);

  if (!bars || bars.length < 2) {
    // Show "No data" overlay instead of leaving it blank
    ctx.fillStyle = '#aaa';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('No data', w / 2, h / 2);
    return;
  }
      const pad = 12;
      const highs = bars.map(b=>b.h), lows = bars.map(b=>b.l);
      let min = Math.min(...lows), max = Math.max(...highs);
      if(robustZoom && bars.length>=5){
        const ql = quantile(lows, 0.05), qh = quantile(highs, 0.95);
        min = Math.min(min, ql); max = Math.max(max, qh);
        // ensure a minimum relative range to keep candles visible
        const mid = (min+max)/2; const rel = (max-min)/Math.max(1e-9, mid);
        const minRel = 0.0015; // 0.15%
        if(rel < minRel){
          const pad = mid*minRel/2;
          min = mid - pad; max = mid + pad;
        }
        // small padding
        const pad2 = (max-min)*0.001;
        min -= pad2; max += pad2;
      }
      const range = (max-min)||1;
      const step = (w - pad*2) / (bars.length-1);
      const bodyFrac = 0.55; // candle body width fraction (mobile-friendly)
      const bodyW = Math.max(2, step * bodyFrac);

      // subtle grid
      ctx.strokeStyle = '#2d2d33';
      ctx.lineWidth = 1;
      for (let i=1;i<=3;i++){
        const y = pad + (h - pad*2) * (i/4);
        ctx.beginPath(); ctx.moveTo(pad,y); ctx.lineTo(w-pad,y); ctx.stroke();
      }

      // wicks + bodies
      for (let i=0;i<bars.length;i++){
        const b = bars[i];
        const x = pad + step*i;
        const yH = h - pad - ((b.h - min)/range)*(h - pad*2);
        const yL = h - pad - ((b.l - min)/range)*(h - pad*2);
        const yO = h - pad - ((b.o - min)/range)*(h - pad*2);
        const yC = h - pad - ((b.c - min)/range)*(h - pad*2);
        const up = b.c >= b.o;

        // wick (always full so you still see range)
        ctx.strokeStyle = up ? '#6abd74' : '#e05d5d';
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(x, yH); ctx.lineTo(x, yL); ctx.stroke();

        // body (last bar can render partially by time progress)
        const top = Math.min(yO, yC), bot = Math.max(yO, yC);
        ctx.fillStyle = up ? '#6abd74' : '#e05d5d';
        const widthScale = (i === bars.length-1) ? (progressLast || 1) : 1;
        const wBody = Math.max(2, bodyW * widthScale);
        ctx.fillRect(x - bodyW/2, top, wBody, Math.max(2, bot-top));
      }

      // overlays: VWAP across closes (proxy). Draw after candles.
      if (opts.vwap){
        let cumPV=0, cumV=0;
        ctx.beginPath();
        ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim()||'#7424ac';
        ctx.setLineDash([5,4]);
        ctx.lineWidth = 2;
        for (let i=0;i<bars.length;i++){
          const b = bars[i];
          const x = pad + step*i;
          cumPV += (b.c||b.o) * (b.v||1);
          cumV  += (b.v||1);
          const vwap = cumPV / Math.max(1,cumV);
          const y = h - pad - ((vwap - min)/range)*(h - pad*2);
          if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        }
        ctx.stroke();
        ctx.setLineDash([]);
      }

      // optional close line for clarity
      if (opts.closeLine){
        ctx.beginPath();
        ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent-graph').trim()||'#7c5cff';
        ctx.lineWidth = 1.75;
        for (let i=0;i<bars.length;i++){
          const b = bars[i];
          const x = pad + step*i;
          const y = h - pad - ((b.c - min)/range)*(h - pad*2);
          if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        }
        ctx.stroke();
      }
    }

    // Simple tiny line chart for sparkline in Prep (unchanged)
    function drawLineChart(canvas,points){
      const {ctx,w,h}=sizeCanvas(canvas);
      if(!points || points.length<2) return;
      const pad=10; const min=Math.min(...points.map(p=>p.c)), max=Math.max(...points.map(p=>p.c)); const range=(max-min)||1;
      const step=(w-pad*2)/(points.length-1);
      ctx.beginPath();
      ctx.lineWidth=2; ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--accent-graph').trim()||'#7c5cff';
      points.forEach((p,i)=>{const x=pad+step*i; const y=h-pad-((p.c-min)/range)*(h-pad*2); if(i===0)ctx.moveTo(x,y); else ctx.lineTo(x,y)});
      ctx.stroke();
    }

    /* ---------------- Prep summary ---------------- */
    async function buildSummary(markets){
      nowEl.textContent=new Date().toLocaleString();
      const gkey=(localStorage.getItem('GNEWS_KEY')||'').trim(), akey=(localStorage.getItem('ALPHA_KEY')||'').trim();
      keyStatusEl.textContent=(!gkey||!akey)?'Using proxy for any missing services.':'Using saved API keys where available.';
      summaryEl.innerHTML='<span class="spinner"></span> Analyzing...';
      let newsRes={ok:false,reason:'timeout'}, dayRes={ok:false,reason:'timeout'};
      try{newsRes=await getHeadlines(markets)}catch(e){newsRes={ok:false,reason:String(e)}}
      try{dayRes=await getLastDayMove(markets)}catch(e){dayRes={ok:false,reason:String(e)}}
      const parts=[];
      if(newsRes.ok&&newsRes.headlines?.length){
        const senti=sentimentFrom(newsRes.headlines);
        const overall=senti.total>=2?'lean <b>bullish</b>':(senti.total<=-2?'lean <b>bearish</b>':'look <b>mixed/neutral</b>');
        parts.push(`<div class="pill ${senti.cls}"><i class="fa-regular fa-newspaper"></i> News sentiment (${newsRes.source}): <strong>${senti.label}</strong></div>`);
        parts.push(`<p style="margin-top:8px">According to current news, <b>${markets.join(', ')}</b> ${overall} as of now.</p>`);
        const top=newsRes.headlines.slice(0,5).map(h=>`<li>${h}</li>`).join('');
        parts.push(`<details style="margin-top:6px"><summary>Top headlines</summary><ul>${top}</ul></details>`);
      } else {
        parts.push(`<div class="muted"><i class="fa-regular fa-newspaper"></i> News sentiment unavailable${newsRes.reason?' ('+newsRes.reason+')':''}</div>`);
      }
      if(dayRes.ok){
        const dir=dayRes.pct>=0?'▲':'▼',cls=dayRes.pct>=0?'ok':'bad';
        let weekendHint=''; try{const dL=new Date(dayRes.latest).getDay(),dP=new Date(dayRes.prior).getDay(); if(dL===1&&dP===5) weekendHint=' (Fri → Mon)';}catch(_){ }
        parts.push(`<div class="pill ${cls}" style="margin-top:8px"><i class="fa-solid fa-chart-line"></i> Prev day (${dayRes.etf}, ${dayRes.source}): ${dir} ${dayRes.pct.toFixed(2)}% (close ${dayRes.latest}${weekendHint})</div>`);
      } else {
        parts.push(`<div class="muted" style="margin-top:8px">Last day summary unavailable${dayRes.reason?' ('+dayRes.reason+')':''}</div>`);
      }
      try{
        const showWhy=dayRes?.ok&&Math.abs(dayRes.pct)>=WHY_PCT;
        if(showWhy){
          const why=buildWhyNarrative({dayRes,headlines:(newsRes.ok?newsRes.headlines:[])});
          parts.push(`<p style="margin-top:10px"><strong>Why?</strong> ${why}</p>`);
        }
      }catch(_){ }
      summaryEl.innerHTML=parts.join('');
      if(dayRes.ok&&dayRes.closes?.length) drawSparkline(summaryEl,dayRes.closes);
    }

    /* ---------------- Intraday fetch ---------------- */
    async function fetchIntraday(etf){
      const u = `https://query1.finance.yahoo.com/v8/finance/chart/${encodeURIComponent(etf)}?range=1d&interval=1m&includePrePost=true&t=${Date.now()}`;
      const _r = (typeof fetchWithFallback==='function') ? await fetchWithFallback(u,'json',12000) : null;
      const data = (_r && _r.ok) ? _r.data : await fetchJsonRetry(PROXY_RAW + encodeURIComponent(u), 2);
      const r = data?.chart?.result?.[0];
      const q = r?.indicators?.quote?.[0];
      const ts = r?.timestamp || [];
      const out = [];
      for (let i = 0; i < ts.length; i++) {
        const o=q?.open?.[i], h=q?.high?.[i], l=q?.low?.[i], _c = q?.close?.[i], v = q?.volume?.[i] ?? 0;
        const c = (_c!=null) ? _c : ((o!=null && h!=null && l!=null) ? (o+h+l)/3 : null);
        if (c != null && h!=null && l!=null && o!=null) out.push({ t: ts[i] * 1000, o, h, l, c, v });
      }

      // Pull regular trading period from Yahoo meta (NYSE session for ETFs)
      const reg = r?.meta?.currentTradingPeriod?.regular;
      const regStart = (reg?.start ? reg.start * 1000 : null);
      const regEnd   = (reg?.end   ? reg.end   * 1000 : null);

      return { bars: out, regStart, regEnd };
    }
    function filterToSession(bars, regStart, regEnd){
      if (regStart) {
        // Include post‑market data; just enforce lower bound from regular session start.
        // If there are no bars yet in the regular session (e.g. before market opens),
        // fall back to the full intraday history so pre‑market bars can be used.
        const sessionBars = bars.filter(b => b.t >= regStart);
        return sessionBars.length > 0 ? sessionBars : bars;
      }
      const MAX_MIN = 390; // fallback: last day of 1‑min bars
      return bars.slice(-MAX_MIN);
    }

    function lastBarProgress(bars){
      if(!bars || !bars.length) return 1;
      const last = bars.at(-1);
      const ageMs = Date.now() - (last.t||Date.now());
      const frac = ageMs/60000; // minute progress
      if(!isFinite(frac)) return 1;
      return Math.max(0.05, Math.min(1, frac)); // min visual width
    }
    function selectWindow(bars,minutes){
      if(!bars.length) return [];
      const cutoff=Date.now()-minutes*60*1000;
      const recent=bars.filter(b=>b.t>=cutoff);
      if(recent.length<Math.min(15,minutes)) return bars.slice(-Math.max(15,minutes));
      return recent;
    }
    function statsTrend(windowBars){
      if(windowBars.length<5) return {ok:false,reason:'not enough bars'};
      const closes=windowBars.map(b=>b.c), vols=windowBars.map(b=>b.v);
      const first=closes[0], last=closes.at(-1);
      const pct=(last-first)/first*100, delta=last-first;
      const rets=[]; for(let i=1;i<closes.length;i++){ const r=(closes[i]-closes[i-1])/closes[i-1]; if(isFinite(r)) rets.push(r); }
      const mean=rets.reduce((a,b)=>a+b,0)/Math.max(1,rets.length);
      const varr=rets.reduce((a,b)=>a+(b-mean)*(b-mean),0)/Math.max(1,rets.length);
      const std=Math.sqrt(varr);
      const median=arr=>{const a=[...arr].sort((x,y)=>x-y); const m=Math.floor(a.length/2); return a.length%2?a[m]:(a[m-1]+a[m])/2;};
      const volMed=median(vols), volAvg=vols.reduce((a,b)=>a+b,0)/vols.length, volRatio=volMed>0?volAvg/volMed:1;
      let sx=0,sy=0,sxx=0,sxy=0; for(let i=0;i<closes.length;i++){ sx+=i; sy+=closes[i]; sxx+=i*i; sxy+=i*closes[i]; }
      const n=closes.length, denom=(n*sxx - sx*sx)||1; const slope=(n*sxy - sx*sy)/denom; const slopePctPerHour=(slope/first)*60*100;
      let direction='Sideways',dirClass='warn'; if(pct>=0.2||slopePctPerHour>=0.5){direction='Uptrend';dirClass='ok'} else if(pct<=-0.2||slopePctPerHour<=-0.5){direction='Downtrend';dirClass='bad'}
      const busy=(std>=0.0006)||(volRatio>=1.20); const busyLabel=busy?'Busy':'Calmer',busyClass=busy?'ok':'warn';
      return {ok:true,pct,delta,std,volRatio,slopePctPerHour,direction,dirClass,busyLabel,busyClass,closes,bars:windowBars}
    }

    function drawTrend(canvas,bars,progressFrac){ drawCandleChart(canvas,bars,{vwap:true,closeLine:true,progressFracLast:progressFrac,robustZoom:true}); }

    function tradeSuggestion(info){
      if(!info?.ok) return {text:'—',action:'Wait'};
      if(info.direction==='Uptrend'&&info.busyLabel==='Busy') return {text:'Recommend: <b>Buy</b> (uptrend + active tape)',action:'Buy'};
      if(info.direction==='Downtrend'&&info.busyLabel==='Busy') return {text:'Recommend: <b>Sell</b> (downtrend + active tape)',action:'Sell'};
      if(info.direction==='Uptrend') return {text:'Recommend: <b>Buy (cautious)</b> (uptrend, calmer tape)',action:'Buy'};
      if(info.direction==='Downtrend') return {text:'Recommend: <b>Sell (cautious)</b> (downtrend, calmer tape)',action:'Sell'};
      return {text:'Recommend: <b>Wait</b> (sideways / mixed)',action:'Wait'};
    }

    function computeVWAP(bars){
      let cumPV=0,cumV=0; const out=[];
      for(const b of bars){ cumPV+= (b.c||b.o)*(b.v||1); cumV+= (b.v||1); out.push(cumPV/Math.max(1,cumV)); }
      return out;
    }

    function setLegend(el){
      if(!el) return;
      el.innerHTML = `
        <span class="item"><span class="swatch" style="background:#6abd74"></span> Up candle</span>
        <span class="item"><span class="swatch" style="background:#e05d5d"></span> Down candle</span>
        <span class="item" style="color:var(--accent-graph)"><span class="swatch line" style="color:var(--accent-graph)"></span> Close line</span>
        <span class="item" style="color:var(--accent)"><span class="swatch line dashed" style="color:var(--accent)"></span> VWAP (proxy)</span>`;
    }

    /* ---------------- Prediction (new purple blip) ---------------- */
    function marketPrediction(info, bars){
      if(!info?.ok || !bars?.length) return {label:'Neutral', conf:0.5, text:'Market bias unclear'};
      const N = Math.min(15, bars.length);
      const lastN = bars.slice(-N);
      const vwapArr = computeVWAP(lastN);
      const last = lastN.at(-1).c; const vwap = vwapArr.at(-1);
      let score = 0;
      // Direction & slope
      if(info.direction==='Uptrend') score += 1; else if(info.direction==='Downtrend') score -= 1;
      score += Math.tanh(info.slopePctPerHour/1.2); // smooth contribution
      // Above/below VWAP
      if(last > vwap) score += 0.6; else score -= 0.6;
      // Recent momentum
      let ups=0,downs=0; for(let i=1;i<lastN.length;i++){const d=lastN[i].c-lastN[i-1].c; if(d>0) ups++; else if(d<0) downs++;}
      if(ups>downs) score += 0.4; else if(downs>ups) score -= 0.4;
      // Volatility: calmer = lower confidence
      const volAdj = Math.max(0.35, Math.min(1, info.busyLabel==='Busy'?1:0.6));
      const conf = Math.max(0.5, Math.min(0.95, (0.6 + Math.abs(score)/3) * volAdj));
      const label = score>0.25? 'Bullish' : (score<-0.25? 'Bearish' : 'Range/Neutral');
      const text = label==='Bullish' ? 'likely to stay bullish' : (label==='Bearish' ? 'may turn/continue bearish' : 'likely range-bound');
      // Forecast the next 5-minute candle body based on the bias strength relative to volatility.
      let forecast;
      const absScore = Math.abs(score);
      if(absScore>1.2) forecast = (score>0 ? 'strong green' : 'strong red');
      else if(absScore>0.5) forecast = (score>0 ? 'green' : 'red');
      else forecast = 'doji/small candle';
      return {label,conf,text,forecast};
    }

    async function buildTrend(markets){
      const etf=FUTURES_TO_ETF[markets[0]||'ES']||'SPY';
      trendSymEl.textContent=etf; trendTimeEl.textContent=new Date().toLocaleString();
      trendSummaryEl.innerHTML='<span class="spinner"></span> Loading 1-minute bars...'; trendAdviceEl.innerHTML='';
      try{
        const all=await fetchIntraday(etf); const sessionBars=filterToSession(all.bars, all.regStart, all.regEnd); const win=selectWindow(sessionBars,trendMinutes); const info=statsTrend(win);
        if(!info.ok){trendSummaryEl.innerHTML=`<span class="muted">Trend unavailable (${info.reason})</span>`;drawTrend(trendCanvas,[]);return}
        const dirPill=`<span class="pill ${info.dirClass}"><i class="fa-solid fa-arrow-trend-${info.direction==='Downtrend'?'down':'up'}"></i> ${info.direction}</span>`;
        const busyPill=`<span class="pill ${info.busyClass}"><i class="fa-solid fa-bolt"></i> ${info.busyLabel}</span>`;
        const pctStr=`${info.pct>=0?'▲':'▼'} ${info.pct.toFixed(2)}%`;
        const slopeStr=`${info.slopePctPerHour>=0?'+':''}${info.slopePctPerHour.toFixed(2)}%/hr slope`;
        const volStr=`σ(1m) ${(info.std*100).toFixed(3)}% • Vol ratio ${info.volRatio.toFixed(2)}×`;
        trendSummaryEl.innerHTML=`${dirPill} ${busyPill}<div style="margin-top:8px" class="muted">${pctStr} • ${slopeStr} • ${volStr}</div>`;
        drawTrend(trendCanvas,win, lastBarProgress(win));
        setLegend(trendLegend);
        const advice=tradeSuggestion(info);
        trendAdviceEl.innerHTML=`<div class="pill autoscroll" id="trendRecPill" style="margin-top:10px;background:#2b2a31;border-color:#3a3941"><i class="fa-solid fa-lightbulb"></i>&nbsp; ${advice.text}</div><div class="muted" style="margin-top:6px;font-size:12px">Disclaimer: This summary is generated solely from current market data in this app and is for informational purposes only. It is not financial advice.</div>`; if (window.matchMedia('(max-width: 520px)').matches) { applyMarquee(document.getElementById('trendRecPill')); }
        const refEl=document.getElementById('trendRef'); if(refEl){refEl.textContent=new Date().toLocaleTimeString();refEl.classList.remove('flash');void refEl.offsetWidth;refEl.classList.add('flash')}
      }catch(e){trendSummaryEl.innerHTML=`<span class="muted">Trend fetch failed (${String(e.message||e)})</span>`;drawTrend(trendCanvas,[])}
    }

    /* ---------------- Risk ---------------- */
    let riskMode='conservative';
    const riskModeSeg=document.getElementById('riskModeSeg');
    let riskCandlesN=3;
    const riskCandles=document.getElementById('riskCandles'), riskCandlesLabel=document.getElementById('riskCandlesLabel');
    // Track previous and pending values for the candles slider
    let prevSliderValue=parseInt(riskCandles?.value||'3',10)||3;
    let pendingSliderValue=null;
    // Flag to remember if the user has already accepted moving the candles slider.
    // Once set to true, further slider changes will skip confirmation and update immediately.
    let sliderConfirmed=false;

    // Update the position of the candles label so it sits above the slider
    // knob.  Called whenever the slider value or layout changes.
    function updateSliderBubble(){
      if(!riskCandles || !riskCandlesLabel) return;
      const min = parseInt(riskCandles.min,10)||0;
      const max = parseInt(riskCandles.max,10)||1;
      const val = parseInt(riskCandles.value,10)||min;
      const percent = (val - min) / Math.max(1, (max - min));
      // Compute horizontal offset relative to the slider row.  We use
      // boundingClientRect so that we subtract the row’s left position.
      const sliderRect = riskCandles.getBoundingClientRect();
      const rowRect    = riskCandles.parentElement.getBoundingClientRect();
      const width      = sliderRect.width;
      const left       = (sliderRect.left - rowRect.left) + percent * width;
      riskCandlesLabel.style.left = `${left}px`;
    }

    if(riskModeSeg){
      riskModeSeg.addEventListener('click',e=>{
        const btn=e.target.closest('.segbtn'); if(!btn) return;
        riskMode=btn.dataset.mode||'conservative';
        Array.from(riskModeSeg.querySelectorAll('.segbtn')).forEach(b=>b.classList.toggle('active',b===btn));
        const m=getSelectedFutures(); buildRisk(m.length?m:['ES']);
      });
    }
    if(riskCandles){
      const syncLabel=()=>{ riskCandlesLabel.textContent=`${riskCandles.value} candles`; };
      // Update label but do not commit value until confirmed
      riskCandles.addEventListener('input',()=>{
        // Reflect the live slider value in the label as the user drags, without committing.
        const val = parseInt(riskCandles.value,10) || prevSliderValue;
        riskCandlesLabel.textContent = `${val} candles`;
      });
      riskCandles.addEventListener('change',(e)=>{
        const newVal=parseInt(e.target.value,10)||3;
        if(newVal===prevSliderValue) { return; }
        // If the user has already confirmed slider changes, apply immediately without asking again.
        if(sliderConfirmed){
          prevSliderValue = newVal;
          riskCandles.value = newVal;
          // Update label to reflect new value
          if(riskCandlesLabel) riskCandlesLabel.textContent = `${newVal} candles`;
          // Immediately rebuild risk with new slider
          const sel=getSelectedFutures();
          buildRisk(sel.length? sel : ['ES']);
          return;
        }
        // Otherwise, show confirmation. Save pending value and revert slider display back to previous
        pendingSliderValue = newVal;
        riskCandles.value = prevSliderValue;
        syncLabel();
        const modal=document.getElementById('sliderConfirm');
        if(modal){
          modal.style.display='flex';
          // Bind click handlers to Accept and Cancel when modal shows.
          const acc=document.getElementById('sliderAccept');
          const can=document.getElementById('sliderCancel');
          if(acc){
            acc.onclick = () => {
              // commit the pending value and mark as confirmed
              if(typeof pendingSliderValue==='number') prevSliderValue = pendingSliderValue;
              sliderConfirmed = true;
              riskCandles.value = prevSliderValue;
              if(riskCandlesLabel) riskCandlesLabel.textContent = `${prevSliderValue} candles`;
              modal.style.display='none';
              const sel2=getSelectedFutures();
              buildRisk(sel2.length? sel2 : ['ES']);
            };
          }
          if(can){
            can.onclick = () => {
              modal.style.display='none';
              riskCandles.value = prevSliderValue;
              if(riskCandlesLabel) riskCandlesLabel.textContent = `${prevSliderValue} candles`;
            };
          }
        }
      });
      // Initial sync
      syncLabel();
    }

    // (Removed direct binding of sliderAccept/sliderCancel here; handlers are bound when the modal opens.)

    function lastNSignal(bars,N){
      const seg=(bars||[]).slice(-N); if(seg.length<N) return {text:'Recommend: <b>Wait</b> (need more bars)',action:'Wait',pct:0,up:false,dn:false};
      let up=true,dn=true; for(let i=1;i<seg.length;i++){if(!(seg[i].c>seg[i-1].c)) up=false; if(!(seg[i].c<seg[i-1].c)) dn=false;}
      const pct=((seg.at(-1).c - seg[0].c)/seg[0].c)*100;
      const base=0.05, thresh=base*(N/3);
      if(up && pct>=thresh) return {text:`Recommend: <b>Buy</b> (Aggressive: last ${N} ↑, +${pct.toFixed(2)}%)`,action:'Buy',pct,up:true,dn:false};
      if(dn && pct<=-thresh) return {text:`Recommend: <b>Sell</b> (Aggressive: last ${N} ↓, ${pct.toFixed(2)}%)`,action:'Sell',pct,up:false,dn:true};
      return {text:`Recommend: <b>Wait</b> (Aggressive: mixed/insufficient move)`,action:'Wait',pct,up:false,dn:false};
    }
    function conservativeSignal(info,bars,N){
      const seg=(bars||[]).slice(-N); if(seg.length<N||!info?.ok) return {text:'Recommend (Conservative): <b>Wait</b> (insufficient data)',action:'Wait'};
      let up=true,dn=true; for(let i=1;i<seg.length;i++){if(!(seg[i].c>seg[i-1].c)) up=false; if(!(seg[i].c<seg[i-1].c)) dn=false;}
      const pct=((seg.at(-1).c - seg[0].c)/seg[0].c)*100;
      const base=0.05, thresh=base*(N/3)*1.6;
      const alignUp = (info.direction==='Uptrend');
      const alignDn = (info.direction==='Downtrend');
      const busyOk  = (info.busyLabel==='Busy');

      if(up && pct>=thresh && (alignUp || busyOk)) return {text:`Recommend (Conservative): <b>Buy</b> (+${pct.toFixed(2)}% over ${N}m, aligned)`,action:'Buy'};
      if(dn && pct<=-thresh && (alignDn || busyOk)) return {text:`Recommend (Conservative): <b>Sell</b> (${pct.toFixed(2)}% over ${N}m, aligned)`,action:'Sell'};
      return {text:`Recommend (Conservative): <b>Wait</b> (safer bias)`,action:'Wait'};
    }
    function leanWindow(bars, minutesDesired){
      const lastN=(bars||[]).slice(-minutesDesired);
      if(lastN.length<2) return null;
      const first=lastN[0].c,last=lastN.at(-1).c; const pct=((last-first)/first)*100;
      let ups=0,downs=0; for(let i=1;i<lastN.length;i++){const d=lastN[i].c-lastN[i-1].c; if(d>0) ups++; else if(d<0) downs++;}
      const dir=(pct>0 || (Math.abs(pct)<1e-9 && ups>=downs))?'Bullish':'Bearish';
      const cls=dir==='Bullish'?'ok':'bad'; return {dir,cls,pct};
    }

    async function buildRisk(markets){
      const etf=FUTURES_TO_ETF[markets[0]||'ES']||'SPY';
      riskSymEl.textContent=etf; riskTimeEl.textContent=new Date().toLocaleString();
      // No need to reposition the candles label; it sits next to the mode buttons.
      riskSummaryEl.innerHTML='<span class="spinner"></span> Loading 1-minute bars...'; riskAdviceEl.innerHTML='';
      try{
        const all=await fetchIntraday(etf);
        const sessionBars=filterToSession(all.bars, all.regStart, all.regEnd);
        const win=selectWindow(sessionBars,trendMinutes);
        const info=statsTrend(win);
        if(!info.ok){riskSummaryEl.innerHTML=`<span class="muted">Risk read unavailable (${info.reason})</span>`;drawTrend(riskCanvas,[]);return}

        const dirPill=`<span class="pill ${info.dirClass}"><i class="fa-solid fa-arrow-trend-${info.direction==='Downtrend'?'down':'up'}"></i> ${info.direction}</span>`;
        const busyPill=`<span class="pill ${info.busyClass}"><i class="fa-solid fa-bolt"></i> ${info.busyLabel}</span>`;
        const pctStr=`${info.pct>=0?'▲':'▼'} ${info.pct.toFixed(2)}%`;
        const slopeStr=`${info.slopePctPerHour>=0?'+':''}${info.slopePctPerHour.toFixed(2)}%/hr slope`;
        const volStr=`σ(1m) ${(info.std*100).toFixed(3)}% • Vol ratio ${info.volRatio.toFixed(2)}×`;
        riskSummaryEl.innerHTML=`${dirPill} ${busyPill}<div style="margin-top:8px" class="muted">${pctStr} • ${slopeStr} • ${volStr}</div>`;
        drawTrend(riskCanvas,win, lastBarProgress(win));
        setLegend(riskLegend);

        const N = Math.max(3, Math.min(15, riskCandlesN||3));
        const M = Math.max(2, Math.min(N, trendMinutes));

        let rec; if(riskMode==='aggressive'){ rec = lastNSignal(win, N); } else { rec = conservativeSignal(info, win, N); }
        // After computing the basic recommendation, perform breakout failure checks and append trade plan.
        {
          const seg=(win||[]).slice(-N);
          if(seg.length===N && rec && (rec.action==='Buy' || rec.action==='Sell')){
            let trigger=false;
            // Determine if the move has retraced beyond a volatility-scaled threshold; if so, revert to Wait.
            if(rec.action==='Buy'){
              let maxClose=-Infinity,lastClose=-Infinity;
              for(const b of seg){ if(b.c>maxClose) maxClose=b.c; }
              lastClose=seg.at(-1).c;
              const thresh=(info.std||0.0008)*3; // volatility-scaled threshold
              if(maxClose>0 && ((maxClose-lastClose)/maxClose)>thresh) trigger=true;
            } else if(rec.action==='Sell'){
              let minClose=Infinity,lastClose=Infinity;
              for(const b of seg){ if(b.c<minClose) minClose=b.c; }
              lastClose=seg.at(-1).c;
              const thresh=(info.std||0.0008)*3;
              if(minClose>0 && ((lastClose-minClose)/minClose)>thresh) trigger=true;
            }
            if(trigger){
              rec.action='Wait';
              rec.text=`Recommend: <b>Wait</b> (breakout retraced)`;
            }
            // Append trade management plan if still actionable
            if(rec.action==='Buy' || rec.action==='Sell'){
              const plan = riskMode==='aggressive' ? 'tight stop; partial profit & runner management' : 'loose stop; scaled targets';
              rec.text += ` – Plan: ${plan}`;
            }
          }
        }
        // Insert the recommendation pill and disclaimer.  Center the pill horizontally
        // within the advice container by using auto margins.
        // Build only the recommendation pill inside riskAdvice.  We'll move the disclaimer
        // outside and group the prediction/lean pills together on one line.
        riskAdviceEl.innerHTML = `
          <div class="pill autoscroll" id="riskRecPill" style="display:inline-flex;margin-top:10px;background:#2b2a31;border-color:#3a3941">
            <i class="fa-solid fa-lightbulb"></i>&nbsp; ${rec.text}
          </div>
        `;
        // Convert long recommendation text into a marquee if overflowing
        if (window.matchMedia('(max-width: 520px)').matches) { if (window.matchMedia('(max-width: 520px)').matches) { applyMarquee(document.getElementById('riskRecPill')); } }

        // NEW: Prediction blip (purple)
        const pred = marketPrediction(info, win);
        const pctConf = Math.round(pred.conf*100);
        const predEl = document.createElement('div');
        predEl.className='pill accent'; predEl.id='riskPredPill'; predEl.style.cursor='pointer'; predEl.title='Tap to see why';
        predEl.innerHTML = `<i class="fa-solid fa-crystal-ball"></i>&nbsp; Prediction: <b>${pred.text}</b> <span class="muted" style="margin-left:6px">(${pctConf}% conf)</span> <span class="muted" style="margin-left:6px">Next 5m: ${pred.forecast}</span>`;

        // Container for prediction and lean pills on the same line
        const pillRow = document.createElement('div');
        pillRow.style.display = 'flex';
        pillRow.style.gap = '8px';
        pillRow.style.flexWrap = 'wrap';
        pillRow.style.marginTop = '8px';
        // Attach click handler directly to the prediction pill before appending
        predEl.addEventListener('click', () => {
          const lastN = win.slice(-Math.min(15, win.length));
          const vwapArr = computeVWAP(lastN);
          const last = lastN.at(-1)?.c;
          const vwapVal = vwapArr.at(-1);
          let parts = [];
          parts.push(`Trend bias: <b>${info.direction}</b> (${info.direction==='Uptrend'?'+1':'Downtrend'==='Downtrend'?'-1':'0'} to score)`);
          parts.push(`Slope contribution: <b>${info.slopePctPerHour.toFixed(2)}%/hr</b> (tanh scaled)`);
          parts.push(`Price vs VWAP: <b>${last>vwapVal?'above':'below'}</b> VWAP`);
          let ups=0, downs=0;
          for(let i=1;i<lastN.length;i++){
            const d = lastN[i].c - lastN[i-1].c;
            if(d>0) ups++; else if(d<0) downs++;
          }
          parts.push(`Recent momentum: <b>${ups} up</b> vs <b>${downs} down</b>`);
          parts.push(`Confidence adjustment: tape is <b>${info.busyLabel}</b>`);
          openExplain({ title:'Why this prediction?', html:`<p>Prediction: <b>${pred.label}</b> (${Math.round(pred.conf*100)}% confidence)</p><ul style='margin-top:6px'>${parts.map(p=>`<li>${p}</li>`).join('')}</ul>` });
        });
        pillRow.appendChild(predEl);
        // We'll attach the recommendation pill handler after appending the pill row
    

        const lean = leanWindow(win, M);
        if(lean){
          const pctStr2=`${lean.pct>=0?'+':''}${lean.pct.toFixed(2)}%`;
          const extra=document.createElement('div');
          extra.className=`pill ${lean.cls}`;
          extra.innerHTML = `<i class="fa-solid fa-clock-rotate-left"></i>&nbsp; Last <b>${M} minutes</b>: leaning <b>${lean.dir}</b> (${pctStr2}).`;
          pillRow.appendChild(extra);
        }
        // Append the row of prediction/lean pills to the advice container
        riskAdviceEl.appendChild(pillRow);

        // Attach click handler to the recommendation pill after it exists.  We bind
        // this here because the element is inserted via innerHTML above.  When
        // clicked, it explains why the recommendation was given.
        {
          const recEl2 = document.getElementById('riskRecPill');
          if(recEl2){
            recEl2.onclick = () => {
              let logic='';
              if(riskMode==='aggressive'){
                logic = `Mode: <b>Aggressive</b> • Last <b>${N}</b> bars checked for consecutive moves.<br>Δ over window: <b>${rec.pct>=0?'+':''}${(rec.pct||0).toFixed(2)}%</b>.`;
              } else {
                logic = `Mode: <b>Conservative</b> • Aligns with window trend & tape.<br>Direction: <b>${info.direction}</b> • Tape: <b>${info.busyLabel}</b> • Δ window: <b>${info.pct>=0?'+':''}${info.pct.toFixed(2)}%</b>.`;
              }
              openExplain({ title:'Why this recommendation?', html:`<p>${rec.text}</p><p class='muted'>${logic}</p>` });
            };
            // Reapply marquee on mobile if needed after binding
            if(window.matchMedia('(max-width: 520px)').matches) { applyMarquee(recEl2); }
          }
        }

        // Move the disclaimer to just above the last refreshed row.  We create or update
        // a dedicated element with id=riskDisclaimer for this.
        {
          const refEl=document.getElementById('riskRef');
          if(refEl){
            const refRow=refEl.parentElement;
            let disc=document.getElementById('riskDisclaimer');
            if(!disc){
              disc=document.createElement('div');
              disc.id='riskDisclaimer';
              disc.className='muted';
              disc.style.marginTop='10px';
              disc.style.fontSize='12px';
              refRow.parentElement.insertBefore(disc, refRow);
            }
            disc.textContent='Disclaimer: This is an automated summary and not financial advice.';
          }
        }
        const refEl=document.getElementById('riskRef'); if(refEl){refEl.textContent=new Date().toLocaleTimeString();refEl.classList.remove('flash');void refEl.offsetWidth;refEl.classList.add('flash')}
        riskWinEl.textContent=`${trendMinutes}m`;
      }catch(e){riskSummaryEl.innerHTML=`<span class="muted">Risk fetch failed (${String(e.message||e)})</span>`;drawTrend(riskCanvas,[])}
    }

    /* ---------------- PnL chips ---------------- */
    const chipAK=document.getElementById('chipAK'), chipBG=document.getElementById('chipBG'), chipAKAll=document.getElementById('chipAKAll'), chipBGAll=document.getElementById('chipBGAll'), chipAKWrap=document.getElementById('chipAKWrap'), chipBGWrap=document.getElementById('chipBGWrap'); const chipAKAllWrap=document.getElementById('chipAKAllWrap'), chipBGAllWrap=document.getElementById('chipBGAllWrap');
    function setChipColor(elWrap,amount){
  elWrap.classList.remove('ok','bad','warn');
  const a = Number(amount)||0;
  if(a > 0) elWrap.classList.add('ok');
  else if(a < 0) elWrap.classList.add('bad');
  else elWrap.classList.add('warn');
}
    // ---------------- PnL totals with proxy fallback ----------------
async function pnlGetTotals(){
  if (!PNL_API || !PNL_TOKEN) {
    chipAK.textContent='N/A'; chipBG.textContent='N/A';
    chipAKAll.textContent='N/A'; chipBGAll.textContent='N/A';
    return;
  }
  const url = `${PNL_API}?token=${encodeURIComponent(PNL_TOKEN)}`;

  async function tryDirect(){
    const r = await fetch(url, { cache: 'no-store' });
    if (!r.ok) throw new Error('HTTP ' + r.status);
    return await r.json();
  }
  async function tryProxy(){
    const fr = await (typeof fetchWithFallback==='function' ? fetchWithFallback(url, 'json', 10000) : Promise.resolve({ok:false, error:'no proxy'}));
    if (!fr.ok) throw new Error(fr.error || 'proxy fail');
    return fr.data;
  }

  try {
    let j;
    try { j = await tryDirect(); }
    catch { j = await tryProxy(); }

    if (!j || !j.ok) throw new Error((j && j.error) || 'bad');

    const ak  = Number(j.today?.AK || 0);
    const bg  = Number(j.today?.BG || 0);
    const aka = Number(j.all?.AK   || 0);
    const bga = Number(j.all?.BG   || 0);

    chipAK.textContent    = `$${ak.toFixed(2)}`;
    chipBG.textContent    = `$${bg.toFixed(2)}`;
    chipAKAll.textContent = `$${aka.toFixed(2)}`;
    chipBGAll.textContent = `$${bga.toFixed(2)}`;
    setChipColor(chipAKWrap, aka); setChipColor(chipBGWrap, bga); setChipColor(chipAKAllWrap, aka); setChipColor(chipBGAllWrap, bga);
  } catch (e) {
    chipAK.textContent='N/A'; chipBG.textContent='N/A';
    chipAKAll.textContent='N/A'; chipBGAll.textContent='N/A';
    chipAKWrap.classList.add('warn'); chipBGWrap.classList.add('warn'); if (chipAKAllWrap) chipAKAllWrap.classList.add('warn'); if (chipBGAllWrap) chipBGAllWrap.classList.add('warn');
    // console.warn('[PnL] totals failed', e);
  }
}
// ------------- PnL: list today's entries & undo last -------------
// ------------- PnL: list today's entries (robust permutations) -------------






async function pnlUndoLast(){
  if (!PNL_API || !PNL_TOKEN) throw new Error('Missing API/token');
  const payload = { token: PNL_TOKEN, action:'undo' };

  // Try POST (preflight-safe), then GET fallback
  try {
    const r = await fetch(PNL_API, {
      method: 'POST',
      headers: { 'Content-Type':'text/plain;charset=UTF-8', 'Accept':'application/json' },
      body: JSON.stringify(payload)
    });
    if (!r.ok) throw new Error('HTTP '+r.status);
    const j = await r.json();
    if (!j.ok) throw new Error(j.error || 'undo failed');
    return j;
  } catch (e){
    try {
      const body = new URLSearchParams(payload).toString();
      const r2 = await fetch(PNL_API, {
        method: 'POST',
        headers: { 'Content-Type':'application/x-www-form-urlencoded', 'Accept':'application/json' },
        body
      });
      if (!r2.ok) throw new Error('HTTP '+r2.status);
      const txt = await r2.text();
      try { const j2 = JSON.parse(txt); if (!j2.ok) throw new Error(j2.error || 'undo failed'); return j2; }
      catch { return { ok:true, raw:txt }; }
    } catch (_){
      // GET fallback
      const url = `${PNL_API}?token=${encodeURIComponent(PNL_TOKEN)}&action=undo`;
      const r3 = await fetch(url, { cache:'no-store' });
      if (!r3.ok) throw new Error('HTTP '+r3.status);
      const j3 = await r3.json();
      if (!j3.ok) throw new Error(j3.error || 'undo failed');
      return j3;
    }
  }
}


    /* ---------------- Prep flow ---------------- */
    function startAnalyze({linksOnly=false}={}){const sel=getSelectedFutures();const markets=sel.length?sel:['ES','NQ'];showPrepHeader(markets);makeLinks(markets);if(!linksOnly)buildSummary(markets);else summaryEl.innerHTML=`<span class="muted">Quick-links mode. Tap Analyze for auto-summary.</span>`;window.scrollTo({top:document.body.scrollHeight,behavior:'smooth'})}

    /* ---------------- Events ---------------- */
    document.getElementById('start').addEventListener('click',()=>{setNav('nav-prep');setTab('prep');startAnalyze({linksOnly:false})});
    document.getElementById('runTrend').addEventListener('click',()=>{setNav('nav-trend');setTab('trend');const m=getSelectedFutures();buildTrend(m.length?m:['ES'])});
    document.getElementById('runRisk').addEventListener('click',()=>{setNav('nav-risk');setTab('risk');const m=getSelectedFutures();buildRisk(m.length?m:['ES'])});

    document.addEventListener('DOMContentLoaded',()=>{

      // Aligned 30s refresh: fires exactly at :00 and :30 to catch new minute bars
      function refreshAllCharts(){
        const m=getSelectedFutures();
        buildTrend(m.length?m:['ES']);
        buildRisk(m.length?m:['ES']);
      }
      function scheduleAlignedRefresh(){
        const now=new Date();
        const s=now.getSeconds(), ms=now.getMilliseconds();
        const until = ((30 - (s % 30)) % 30) * 1000 + (1000 - ms);
        setTimeout(()=>{
          refreshAllCharts();
          setInterval(refreshAllCharts, 30000);
        }, Math.max(50, until));
      }

      // auto-scroll the top stat chips like a ticker
      const strip=document.querySelector('.statstrip'); if(strip && window.matchMedia('(max-width: 520px)').matches) autoScrollContainer(strip, 18);
      pnlGetTotals(); setInterval(pnlGetTotals,120000); const btn=document.getElementById('logPnl'), msg=document.getElementById('pnlMsg');
      if(btn){btn.addEventListener('click',async()=>{try{const who=(document.querySelector('input[name="who"]:checked')||{}).value||'AK';const amt=(document.getElementById('pnlAmount')||{}).value||'';const note=(document.getElementById('pnlNote')||{}).value||'';if(!amt||isNaN(Number(amt))){msg.textContent='Enter a number (e.g. 125 or -75)';return}msg.textContent='Saving...';await pnlPostLog({user:who,amount:amt,note});msg.textContent='Saved ✓';document.getElementById('pnlAmount').value='';document.getElementById('pnlNote').value='';await pnlGetTotals();setTimeout(()=>msg.textContent='',1200)}catch(e){msg.textContent='Error: '+(e.message||e)}})}
      const undoBtn=document.getElementById('undoLast'); if(undoBtn) undoBtn.addEventListener('click', async ()=>{ const msg=document.getElementById('pnlMsg'); try{ if(msg) msg.textContent='Undoing...'; await pnlUndoLast(); if(msg) msg.textContent='Undone ✓'; await pnlGetTotals(); setTimeout(()=>{ if(msg) msg.textContent=''; }, 1200);} catch(e){ if(msg) msg.textContent='Undo failed: '+(e.message||e); } });
      setTfActive(15);

      // Start aligned refresh loop
      scheduleAlignedRefresh();
    });

    
    
    
    /* ======= Explain modal helpers (robust binding) ======= */
    function ensureExplainBindings(){
      const m=document.getElementById('explainModal'); if(!m||m.dataset.bound==='1') return;
      m.dataset.bound='1';
      const c=document.getElementById('explainClose');
      const close=()=>{ m.style.display='none'; };
      if(c){ c.addEventListener('click', (e)=>{ e.stopPropagation(); close(); }); }
      // click outside closes
      m.addEventListener('click', (e)=>{ if(e.target===m) close(); });
      // ESC closes
      window.addEventListener('keydown', (e)=>{ if(e.key==='Escape' && m.style.display!=='none') close(); });
    }
    function openExplain({title='Why?', html=''}){
      const m=document.getElementById('explainModal'); if(!m) return;
      ensureExplainBindings();
      const t=document.getElementById('explainTitle'); const b=document.getElementById('explainBody');
      t.textContent=title; b.innerHTML=html;
      m.style.display='flex';
    }

    /* ======= Auto-scroll utilities ======= */
    function applyMarquee(el, minDur=10, pxPerSec=50){
      if(!el) return;
      // Only marquee if it would overflow
      if (el.scrollWidth <= el.clientWidth + 1) return;
      // If content fits, skip.
      const text = el.textContent.trim();
      if(!text) return;
      // Duplicate content for seamless loop
      el.classList.add('autoscroll');
      el.innerHTML = `<span class="track">${text}&nbsp;&nbsp;•&nbsp;&nbsp;${text}</span>`;
      // Duration proportional to content width
      requestAnimationFrame(()=>{
        const track = el.querySelector('.track');
        if(!track) return;
        const halfWidth = track.getBoundingClientRect().width/2;
        const dur = Math.max(minDur, halfWidth/pxPerSec);
        track.style.setProperty('--dur', dur+'s');
      });
    }
    function autoScrollContainer(el, pxPerSec=30){
      if(!el) return;
      el.style.scrollBehavior = 'auto';
      el.style.overflowX = 'auto';
      let last = performance.now();
      function step(t){
        const dt = (t-last)/1000; last = t;
        el.scrollLeft += pxPerSec * dt;
        if(el.scrollLeft >= el.scrollWidth - el.clientWidth - 1) el.scrollLeft = 0;
        requestAnimationFrame(step);
      }
      requestAnimationFrame(step);
    }

    // ======== Minimal P&L logger post (stubbed same as before) ========
    // ======== Minimal P&L logger post (preflight-safe & robust) ========
async function pnlPostLog({ user, amount, note }){
  if (!PNL_API) throw new Error('PNL_API missing');
  const payload = { token: PNL_TOKEN, user, amount, note };

  // Try simple text/plain first (avoids CORS preflight in most browsers)
  try {
    const r = await fetch(PNL_API, {
      method: 'POST',
      headers: { 'Content-Type': 'text/plain;charset=UTF-8', 'Accept': 'application/json' },
      body: JSON.stringify(payload)
    });
    if (!r.ok) throw new Error('HTTP ' + r.status);
    const j = await r.json();
    if (!j.ok) throw new Error(j.error || 'save failed');
    return j;
  } catch (e) {
    // Fallback: x-www-form-urlencoded (also avoids preflight)
    const body = new URLSearchParams(payload).toString();
    const r2 = await fetch(PNL_API, {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded', 'Accept': 'application/json' },
      body
    });
    if (!r2.ok) throw new Error('HTTP ' + r2.status);
    const txt = await r2.text();
    try {
      const j2 = JSON.parse(txt);
      if (!j2.ok) throw new Error(j2.error || 'save failed');
      return j2;
    } catch {
      // If Apps Script returns plain OK
      return { ok: true, raw: txt };
    }
  }
}
  </script>
<!-- Explain Modal -->
<div class="modal" id="explainModal" style="display:none;position:fixed;inset:0;z-index:200;align-items:center;justify-content:center;background:rgba(0,0,0,.6)">
<div class="box" style="max-width:640px;width:calc(100% - 28px);background:var(--panel);border:1px solid var(--line);border-radius:14px;box-shadow:var(--shadow);padding:16px">
<div class="row" style="justify-content:space-between;align-items:center">
<strong id="explainTitle">Why?</strong>
<button aria-label="Close" class="iconbtn" id="explainClose"><i class="fa-solid fa-xmark"></i></button>
</div>
<div class="muted" id="explainBody" style="margin-top:10px;line-height:1.5"></div>
</div>
</div>
<!-- Slider adjustment confirmation -->
<div id="sliderConfirm" style="display:none;position:fixed;inset:0;z-index:300;align-items:center;justify-content:center;background:rgba(0,0,0,0.65)">
<div style="background:var(--panel);border:1px solid var(--line);box-shadow:var(--shadow);border-radius:14px;padding:20px;max-width:320px;width:calc(100% - 40px);color:var(--fg)">
<div class="muted">Moving the candles slider will look at more bars and may change the recommendation.</div>
<div class="actions" style="margin-top:14px;justify-content:flex-end;gap:10px">
<button class="primary" id="sliderAccept">Accept</button>
<button id="sliderCancel">Cancel</button>
</div>
</div>
</div>
<!-- slider bubble sync (minimal) -->
<script>
(function(){
  const riskCandles = document.getElementById('riskCandles');
  const riskCandlesLabel = document.getElementById('riskCandlesLabel');
  const fn = (typeof window.updateSliderBubble === 'function') ? window.updateSliderBubble : null;
  if(fn){ try{ fn(); }catch(e){} }
  if(riskCandles && fn){
    // guard against double-binding using a data-flag
    if(!riskCandles.dataset.bubbleWired){
      riskCandles.addEventListener('input', fn, {passive:true});
      riskCandles.dataset.bubbleWired = '1';
    }
  }
  // Always handle layout changes
  if(fn){ window.addEventListener('resize', fn); }
})();
</script>
<script id="risk-tabs-lite-js">// LITE_STICKY_QOL v2 (external JS build)
(function(){
  var cache = Object.create(null);
  var initialized = false;
  var preferSym = null;
  var building  = false;

  var LS_KEY = {
    sticky: 'riskTabs.sticky',
    order:  'riskTabs.order',
    pinned: 'riskTabs.pinned',
    last:   'riskTabs.lastActive'
  };
  function loadSet(key){ try{ return new Set(JSON.parse(localStorage.getItem(key)||'[]')); }catch(_){ return new Set(); } }
  function saveSet(key, set){ try{ localStorage.setItem(key, JSON.stringify(Array.from(set||[]))); }catch(_){ } }
  function loadMap(key){ try{ return JSON.parse(localStorage.getItem(key)||'{}')||{}; }catch(_){ return {}; } }
  function saveMap(key, obj){ try{ localStorage.setItem(key, JSON.stringify(obj||{})); }catch(_){ } }
  function loadArr(key){ try{ return JSON.parse(localStorage.getItem(key)||'[]')||[]; }catch(_){ return []; } }
  function saveArr(key, arr){ try{ localStorage.setItem(key, JSON.stringify(arr||[])); }catch(_){ } }
  function saveLast(sym){ try{ localStorage.setItem(LS_KEY.last, sym||''); }catch(_){ } }
  function loadLast(){ try{ return localStorage.getItem(LS_KEY.last)||null; }catch(_){ return null; } }

  var sticky = loadSet(LS_KEY.sticky);
  var pinned = loadMap(LS_KEY.pinned);
  var order  = loadArr(LS_KEY.order);

  function $(s, r){ return (r||document).querySelector(s); }
  function $all(s, r){ return Array.from((r||document).querySelectorAll(s)); }

  function riskPanel(){ return document.getElementById('panel-risk') || document.querySelector('[id^="panel-risk"]') || document.body; }
  function riskOut(){
    return document.getElementById('riskOut')
      || $('#panel-risk #riskOut')
      || $('#panel-risk [data-risk-out]')
      || $('#panel-risk .risk-out')
      || $('#panel-risk .card > div, #panel-risk .card section')
      || null;
  }
  function getSelect(){ return document.getElementById('futures'); }

  function symbolsFromChips(){
    var t = document.getElementById('multiSymbolTabs'); if (!t) return [];
    return $all('.tabbtn', t).map(function(b){
      var s=(b.dataset.sym||b.textContent||'').replace('×','').trim().toUpperCase();
      return /^[A-Z0-9]{1,4}$/.test(s)?s:null;
    }).filter(Boolean);
  }
  function selectedSymbols(){
    var sel = getSelect(); if (!sel) return [];
    var out=[];
    Array.from(sel.options).forEach(function(o){
      if (!o.selected) return;
      var tok=(o.value||o.text||o.innerText||'').trim().split(/\s|—|-/)[0].toUpperCase();
      if (/^[A-Z0-9]{1,4}$/.test(tok)) out.push(tok);
    });
    return out.filter((s,i,a)=>a.indexOf(s)===i);
  }
  function desiredSymbols(){
    var chips = symbolsFromChips();
    if (chips.length) return chips;
    return selectedSymbols();
  }

  function modeKey(){
    var root=riskPanel();
    var el=root.querySelector('[data-mode].active,[data-risk-mode].active,[aria-pressed="true"][data-mode],[aria-pressed="true"][data-risk-mode]');
    if (el) return (el.getAttribute('data-mode')||el.getAttribute('data-risk-mode')||'').toLowerCase();
    var btns=$all('button,.btn,[role="button"]',root);
    for (var i=0;i<btns.length;i++){
      var b=btns[i],t=(b.textContent||'').trim().toLowerCase();
      var pressed=b.matches('.active,[aria-pressed="true"]');
      if (pressed&&(t.includes('conservative')||t.includes('aggressive'))) return t.includes('conservative')?'conservative':'aggressive';
    }
    var sel=root.querySelector('select[name*="mode" i]'); if (sel) return (sel.value||'').toLowerCase();
    var rad=root.querySelector('input[type="radio"][name*="mode" i]:checked'); if (rad) return (rad.value||'').toLowerCase();
    return 'default';
  }
  function timeframeKey(){
    var root=riskPanel();
    var el=root.querySelector('[data-timeframe].active,[data-tf].active,[aria-pressed="true"][data-timeframe]');
    if (el) return (el.getAttribute('data-timeframe')||el.getAttribute('data-tf')||'').toLowerCase();
    var tfBtn=Array.from(root.querySelectorAll('button,.btn,.chip,.tag')).find(function(b){
      var active=b.matches('.active,[aria-pressed="true"]');
      var txt=(b.textContent||'').trim().toLowerCase();
      return active && (/^\d{1,3}\s*(m|min|minutes|h|hr|hour)s?$/i).test(txt);
    });
    if (tfBtn){ return (tfBtn.textContent||'').trim().toLowerCase().replace(/\s+/g,''); }
    return 'tf-default';
  }
  function ctxKey(sym){ return [sym, modeKey(), timeframeKey()].join('|'); }

  function ensureBar(){
    var out=riskOut(); if (!out) return null;
    var bar=document.getElementById('riskTabBar');
    if (!bar){
      bar=document.createElement('div'); bar.id='riskTabBar';
      out.parentNode.insertBefore(bar,out);
      var spacer=document.createElement('div'); spacer.className='spacer'; bar.appendChild(spacer);
      var menu=document.createElement('button'); menu.type='button'; menu.className='menuBtn'; menu.textContent='⋯';
      menu.addEventListener('click', function(ev){ ev.stopPropagation(); toggleContextMenu(ev.pageX, ev.pageY, null); }, false);
      bar.appendChild(menu);
    }else{
      if (!bar.querySelector('.spacer')){
        var spacer=document.createElement('div'); spacer.className='spacer'; bar.appendChild(spacer);
        var menu=document.createElement('button'); menu.type='button'; menu.className='menuBtn'; menu.textContent='⋯';
        menu.addEventListener('click', function(ev){ ev.stopPropagation(); toggleContextMenu(ev.pageX, ev.pageY, null); }, false);
        bar.appendChild(menu);
      }
    }
    return bar;
  }

  function shimmer(out){ if (out) out.innerHTML='<div class="risk-shimmer"></div>'; }

  function setActiveUI(sym){
    var bar=document.getElementById('riskTabBar'); if (!bar) return;
    $all('.rtab',bar).forEach(function(b){ b.classList.toggle('active', b.dataset.sym===sym); });
    try{ window.currentSymbol=sym; document.dispatchEvent(new CustomEvent('symbolchange',{detail:{symbol:sym,pane:'risk'}})); }catch(_){}
    try{ localStorage.setItem(LS_KEY.last, sym||''); }catch(_){}
  }
  function selectInDOM(sym){
    var sel=getSelect(); if (!sel) return;
    var idx=-1;
    for (var i=0;i<sel.options.length;i++){
      var o=sel.options[i]; var tok=(o.value||o.text||o.innerText||'').trim().split(/\s|—|-/)[0].toUpperCase();
      if (tok===sym){ o.selected=true; idx=i; }
    }
    if (idx>=0) sel.selectedIndex=idx;
    sel.dispatchEvent(new Event('input',{bubbles:true}));
    sel.dispatchEvent(new Event('change',{bubbles:true}));
  }
  function findAnalyzeBtn(){
    return document.getElementById('btnAnalyzeRisk')
      || document.getElementById('btnRisk')
      || document.querySelector('[data-action="risk"]')
      || Array.from(document.querySelectorAll('button,.btn,[role="button"]')).find(function(el){
           var t=(el.textContent||'').toLowerCase(); return t.includes('analyze')&&t.includes('risk');
         }) || null;
  }
  function observeOnce(el,cb){
    if (!el || typeof MutationObserver==='undefined'){ setTimeout(cb,600); return; }
    var obs=new MutationObserver(function(){ obs.disconnect(); cb(); });
    obs.observe(el,{childList:true,subtree:true});
    setTimeout(function(){ try{obs.disconnect();}catch(_){ } try{ cb(); }catch(_){ } },2500);
  }
  function runAnalyze(sym){
    var out=riskOut(); if (!out) return;
    var btn=findAnalyzeBtn(); if (!btn) return;
    selectInDOM(sym); shimmer(out);
    observeOnce(out,function(){ try{ var html=out.innerHTML; if(!/risk-shimmer|Loading 1-minute bars/i.test(html)) cache[ctxKey(sym)]=html; }catch(_){ } });
    btn.click();
  }
  function activate(sym){
    preferSym=sym; setActiveUI(sym);
    var out=riskOut(); if (!out) return;
    var key=ctxKey(sym);
    if (cache[key]){ selectInDOM(sym); out.innerHTML = cache[key]; return; }if(/risk-shimmer|Loading 1-minute bars/i.test(cache[key])){ try{ delete cache[key]; }catch(_){ } } else { return; } }
    runAnalyze(sym);
  }

  function togglePin(sym, btn){
    pinned[sym]=!pinned[sym]; if (!pinned[sym]) delete pinned[sym];
    saveMap(LS_KEY.pinned,pinned);
    if (btn) btn.classList.toggle('pinned', !!pinned[sym]);
  }

  function makeTab(sym){
    sticky.add(sym); saveSet(LS_KEY.sticky,sticky);
    if (order.indexOf(sym)===-1){ order.push(sym); saveArr(LS_KEY.order,order); }
    var b=document.createElement('button');
    b.type='button'; b.className='rtab'+(pinned[sym]?' pinned':''); b.dataset.sym=sym; b.draggable=true;
    b.innerHTML='<span class="label">'+sym+'</span> <span class="pin" title="Pin">📌</span> <span class="close" title="Close">×</span>';
    b.addEventListener('click',function(ev){
      var t=ev.target;
      if (t.classList && t.classList.contains('close')){
        sticky.delete(sym); saveSet(LS_KEY.sticky,sticky);
        var idx=order.indexOf(sym); if (idx>-1){ order.splice(idx,1); saveArr(LS_KEY.order,order); }
        b.remove();
        var active=document.querySelector('#riskTabBar .rtab.active');
        if (!active){
          var first=document.querySelector('#riskTabBar .rtab'); if (first) activate(first.dataset.sym);
          else { var o=riskOut(); if (o) o.innerHTML=''; }
        }
        return;
      }
      if (t.classList && t.classList.contains('pin')){ togglePin(sym,b); return; }
      activate(sym);
    },false);
    b.addEventListener('auxclick',function(ev){ if (ev.button===1){ ev.preventDefault(); b.querySelector('.close').click(); } });
    b.addEventListener('dragstart',function(ev){ ev.dataTransfer.setData('text/plain',sym); ev.dataTransfer.effectAllowed='move'; });
    b.addEventListener('dragover',function(ev){ ev.preventDefault(); ev.dataTransfer.dropEffect='move'; });
    b.addEventListener('drop',function(ev){
      ev.preventDefault(); var src=ev.dataTransfer.getData('text/plain'); if (!src||src===sym) return;
      var bar=document.getElementById('riskTabBar'); var srcBtn=bar.querySelector('.rtab[data-sym="'+src+'"]'); if (!srcBtn) return;
      var rect=b.getBoundingClientRect();
      if (ev.clientX < rect.left + rect.width/2){ bar.insertBefore(srcBtn,b); } else { bar.insertBefore(srcBtn,b.nextSibling); }
      order=Array.from(bar.querySelectorAll('.rtab')).map(function(x){ return x.dataset.sym; });
      saveArr(LS_KEY.order,order);
    });
    b.addEventListener('contextmenu',function(ev){ ev.preventDefault(); toggleContextMenu(ev.pageX,ev.pageY,sym); });
    return b;
  }

  function uniq(list){ var seen=new Set(), out=[]; list.forEach(function(s){ if (!seen.has(s)){ seen.add(s); out.push(s); } }); return out; }
  function existingTabSymbols(){
    var bar=document.getElementById('riskTabBar'); if (!bar) return [];
    return Array.from(bar.querySelectorAll('.rtab')).map(function(b){ return b.dataset.sym; });
  }

  function buildTabs(prefer){
    if (building) return; building=true;
    var bar=ensureBar(); if (!bar){ building=false; return; }

    var desired = desiredSymbols();
    var union = uniq([].concat(existingTabSymbols(), Array.from(sticky), desired));

    if (order && order.length){
      union.sort(function(a,b){
        var ia=order.indexOf(a), ib=order.indexOf(b);
        if (ia===-1 && ib===-1) return 0;
        if (ia===-1) return 1;
        if (ib===-1) return -1;
        return ia-ib;
      });
    }

    union.forEach(function(sym){
      if (!bar.querySelector('.rtab[data-sym="'+sym+'"]')){
        var btn=makeTab(sym);
        var spacer=bar.querySelector('.spacer');
        bar.insertBefore(btn, spacer || null);
      }else{
        var ex=bar.querySelector('.rtab[data-sym="'+sym+'"]');
        ex.classList.toggle('pinned', !!pinned[sym]);
      }
    });

    var last = prefer || preferSym || loadLast();
    var target = (last && union.indexOf(last)!==-1) ? last
                : (document.querySelector('#riskTabBar .rtab.active')||{}).dataset?.sym
                || union[0] || null;
    if (target){
      setActiveUI(target);
      var out=riskOut();
      if (out && !out.innerHTML.trim()){ activate(target); }
    }

    building=false;
  }

  var ctx=document.getElementById('riskContext');
  if (!ctx){ ctx=document.createElement('div'); ctx.id='riskContext'; document.body.appendChild(ctx); }
  function hideContext(){ ctx.style.display='none'; }
  function toggleContextMenu(x,y,sym){
    var bar=document.getElementById('riskTabBar'); if (!bar) return;
    var active=(document.querySelector('#riskTabBar .rtab.active')||{}).dataset?.sym || sym;
    ctx.innerHTML='';
    function add(label,fn){ var i=document.createElement('div'); i.className='mi'; i.textContent=label; i.addEventListener('click',function(ev){ ev.stopPropagation(); hideContext(); fn&&fn(); }); ctx.appendChild(i); }
    if (sym){
      add('Close', function(){ var b=bar.querySelector('.rtab[data-sym="'+sym+'"]'); if (b) b.querySelector('.close').click(); });
      add(pinned[sym]?'Unpin':'Pin', function(){ var b=bar.querySelector('.rtab[data-sym="'+sym+'"]'); if (b) togglePin(sym,b); });
      ctx.appendChild(document.createElement('hr'));
    }
    add('Close others', function(){
      Array.from(bar.querySelectorAll('.rtab')).forEach(function(b){ var s=b.dataset.sym; if (s!==active && !pinned[s]){ b.querySelector('.close').click(); } });
    });
    add('Close all (keep pinned)', function(){
      Array.from(bar.querySelectorAll('.rtab')).forEach(function(b){ var s=b.dataset.sym; if (!pinned[s]){ b.querySelector('.close').click(); } });
    });
    ctx.appendChild(document.createElement('hr'));
    add('Clear cache (active)', function(){ var key=ctxKey(active); delete cache[key]; });
    add('Clear cache (all)', function(){ cache = Object.create(null); });

    ctx.style.left=(x+4)+'px'; ctx.style.top=(y+4)+'px'; ctx.style.display='block';
  }
  document.addEventListener('click', hideContext, true);
  document.addEventListener('scroll', hideContext, true);
  window.addEventListener('blur', hideContext);

  document.addEventListener('keydown', function(e){
    var root=riskPanel(); if (!root.contains(document.activeElement) && !root.matches(':hover')) return;
    var bar=document.getElementById('riskTabBar'); if (!bar) return;
    var tabs=Array.from(bar.querySelectorAll('.rtab')); if (!tabs.length) return;
    var idx=Math.max(0,tabs.findIndex(x=>x.classList.contains('active')));
    function go(i){ if (i<0) i=tabs.length-1; if (i>=tabs.length) i=0; tabs[i].click(); }
    if ((e.ctrlKey||e.metaKey) && (e.key==='w'||e.key==='W')){ e.preventDefault(); var a=tabs[idx]; if (a) a.querySelector('.close').click(); return; }
    if ((e.ctrlKey && e.key==='PageUp') || (e.altKey && e.key==='ArrowLeft')){ e.preventDefault(); go(idx-1); return; }
    if ((e.ctrlKey && e.key==='PageDown') || (e.altKey && e.key==='ArrowRight')){ e.preventDefault(); go(idx+1); return; }
  }, true);

  function wireAnalyzeOnce(){
    if (initialized) return;
    var btn=findAnalyzeBtn(); if (!btn) return;
    initialized=true;
    btn.addEventListener('click', function(){
      setTimeout(function(){ buildTabs(preferSym||null); }, 300);
    }, false);
  }

  document.addEventListener('click', function(e){
    var root=riskPanel(); if (!root.contains(e.target)) return;
    var t=(e.target.textContent||'').toLowerCase();
    var looksMode=t.includes('conservative')||t.includes('aggressive')||e.target.matches('[data-mode],[data-risk-mode]');
    var looksTF=e.target.matches('[data-timeframe],[data-tf]')||/^\s*\d{1,3}\s*(m|min|minutes|h|hr|hour)s?\s*$/i.test((e.target.textContent||''));
    if (looksMode||looksTF){
      var out=riskOut(); if (!out) return;
      var el=document.querySelector('#riskTabBar .rtab.active'); var active=el?el.dataset.sym:preferSym;
      if (!active) return;
      observeOnce(out,function(){ try{ var html=out.innerHTML; if(!/risk-shimmer|Loading 1-minute bars/i.test(html)) cache[ctxKey(active)]=html; }catch(_){ } });
    }
  }, true);

  window.addEventListener('load', function(){
    try{ wireAnalyzeOnce(); }catch(_){}
    setTimeout(wireAnalyzeOnce, 500);
    setTimeout(wireAnalyzeOnce, 1200);
    setTimeout(function(){ buildTabs(localStorage.getItem(LS_KEY.last)||null); }, 600);
  });

  window.riskTabsForceRebuild = function(){ buildTabs(preferSym||null); };
})();
</script><script id="risk-tabs-refresh-bridge">
// Bridge v3: sync chips + select + force analyze on tab click (works for pinned tabs)
(function(){
  var pending = null;

  function $(s, r){ return (r||document).querySelector(s); }
  function $$(s, r){ return Array.from((r||document).querySelectorAll(s)); }

  // --- symbol helpers ---
  function symTok(s){
    return (s||'').replace(/[×✕✖📌★]/g,'').trim().split(/\s+/)[0].toUpperCase();
  }
  function getSymbolFromNode(node){
    if (!node) return null;
    var el = node.closest('.rtab,.tabbtn,[data-sym]') || node;
    var sym = el.getAttribute('data-sym') || el.getAttribute('aria-label') || el.textContent || '';
    sym = symTok(sym);
    return (/^[A-Z0-9]{1,4}$/).test(sym) ? sym : null;
  }

  // --- DOM sync: chips row (#multiSymbolTabs) ---
  function syncChips(sym){
    var row = document.getElementById('multiSymbolTabs');
    if (!row) return;
    var btn = row.querySelector('.tabbtn[data-sym="'+sym+'"]') || Array.from(row.querySelectorAll('.tabbtn')).find(function(b){ return symTok(b.textContent)===sym; });
    if (!btn) return;
    // mark active and move to front to be "primary"
    Array.from(row.querySelectorAll('.tabbtn')).forEach(function(b){ b.classList.toggle('active', b===btn); });
    if (btn.previousElementSibling){
      row.insertBefore(btn, row.firstElementChild || null);
    }
  }

  // --- DOM sync: multi-select ---
  function findMultiSelect(){
    var sel = document.getElementById('futures');
    if (sel) return sel;
    // Fallback: any multiple <select> inside the market chooser card
    var picks = $$('select[multiple]');
    if (picks.length) return picks[0];
    return null;
  }
  function setMultiSelect(sym){
    var sel = findMultiSelect(); if (!sel) return;
    var targetIndex = -1;
    for (var i=0;i<sel.options.length;i++) sel.options[i].selected = false;
    for (var j=0;j<sel.options.length;j++){
      var o = sel.options[j];
      var tok = symTok((o.value||o.text||o.innerText||''));
      if (tok === sym){ o.selected = true; targetIndex = j; break; }
    }
    if (targetIndex >= 0) sel.selectedIndex = targetIndex;
    sel.dispatchEvent(new Event('input',  {bubbles:true, cancelable:true}));
    sel.dispatchEvent(new Event('change', {bubbles:true, cancelable:true}));
  }

  // --- native refresh hooks or Analyze (Risk) ---
  function findAnalyzeBtn(){
    return document.getElementById('btnAnalyzeRisk')
        || document.getElementById('btnRisk')
        || document.querySelector('[data-action="risk"]')
        || Array.from(document.querySelectorAll('button, .btn, [role="button"]')).find(function(el){
             var t=(el.textContent||'').toLowerCase();
             return t.includes('analyze') && t.includes('risk');
           }) || null;
  }
  function nativeRefresh(sym){
    try{
      if (typeof window.refreshRisk === 'function'){ window.refreshRisk(sym); return true; }
      if (typeof window.renderSymbol === 'function'){ window.renderSymbol(sym); return true; }
      if (typeof window.refreshSymbol === 'function'){ window.refreshSymbol(sym); return true; }
    }catch(_){}
    return false;
  }
  function reAnalyze(sym){
    if (!sym) return;
    try{ if (pending) clearTimeout(pending); }catch(_){}
    pending = setTimeout(function(){
      syncChips(sym);
      setMultiSelect(sym);
      selectInDOM(sym);
      if (!nativeRefresh(sym)) {  try {    if (typeof window.buildRisk === 'function') {      const m = (typeof getSelectedFutures==='function') ? getSelectedFutures() : [sym];      window.buildRisk(Array.isArray(m)&&m.length?m:[sym]);    } else {      var btn = findAnalyzeBtn(); if (btn) btn.click();    }  } catch(_) {    var btn = findAnalyzeBtn(); if (btn) btn.click();  }}
    }, 50);
  }

  function bind(){
    var bar = document.getElementById('riskTabBar');
    if (!bar || bar.dataset._bridgedV3) return;
    bar.dataset._bridgedV3 = '1';

    function handler(e){
      var tab = e.target.closest('.rtab');
      if (!tab) return;
      if (e.type === 'auxclick' && e.button === 1) return; // middle-click for close
      if (e.target && e.target.classList && (e.target.classList.contains('close') || e.target.classList.contains('pin'))) return;
      var sym = getSymbolFromNode(tab);
      if (!sym) return;
      // Let internal handler mark active; then force re-analyze
      setTimeout(function(){  try{ activate(sym); }catch(_){ reAnalyze(sym); }  try{ if(typeof window.syncChips==='function'){ syncChips(sym); } }catch(_){ }  try{ if(typeof window.buildRisk==='function'){    const m=(typeof getSelectedFutures==='function')?getSelectedFutures():[sym];    window.buildRisk(Array.isArray(m)&&m.length?m:[sym]);  }}catch(_){ }},0);}
    bar.addEventListener('click', handler, false);
    bar.addEventListener('pointerup', handler, false);
    bar.addEventListener('auxclick', handler, false);
  }

  function observe(){
    var panel = document.getElementById('panel-risk') || document.body;
    if (!panel || typeof MutationObserver === 'undefined') return;
    var mo = new MutationObserver(function(){
      try{ bind(); }catch(_){}
    });
    mo.observe(panel, {childList:true, subtree:true});
  }

  function boot(){
    try{ bind(); }catch(_){}
    var tries = 10;
    (function again(){
      if (tries-- <= 0) return;
      setTimeout(function(){ try{ bind(); }catch(_){ } again(); }, 300);
    })();
    try{ observe(); }catch(_){}
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', boot, {once:true});
  } else {
    boot();
  }
  window.addEventListener('load', function(){ try{ bind(); }catch(_){} });
})();
</script>
<script>
(()=>{
  const ready = (fn)=>{
    if (document.readyState === 'complete' || document.readyState === 'interactive') { setTimeout(fn,0); }
    else { document.addEventListener('DOMContentLoaded', fn); }
  };
  ready(()=>{
    try {
      const setNav = window.setNav || (function(){});
      const el = (id)=>document.getElementById(id);

      const navSettings = el('nav-settings') || document.querySelector('[data-nav="nav-settings"]');
      const navPnL      = el('nav-pnl')      || document.querySelector('[data-nav="nav-pnl"]');
      const navPrepId   = 'nav-prep';

      const makeToggle = (node, showId)=>{
        if (!node) return;
        node.onclick = (ev)=>{
          try { ev.preventDefault(); } catch(e){}
          const isActive = node.classList.contains('active');
          setNav(isActive ? navPrepId : showId);
          return false;
        };
      };

      makeToggle(navSettings, 'nav-settings');
      makeToggle(navPnL, 'nav-pnl');
    } catch(e){ /* no-op */ }
  });
})();
</script>


<script>
(()=>{
  const safe = (fn)=>{ try{ fn(); }catch(_){} };
  const getActiveNavId = ()=>{
    const a = document.querySelector('.topnav .active, [data-nav].active, .nav .active');
    return a?.id || a?.getAttribute?.('data-nav') || '';
  };
  const getSymbols = ()=>{
    // Try helper if present, else fallbacks
    let sel = [];
    try { if (typeof getSelectedFutures === 'function') sel = getSelectedFutures(); } catch(e){}
    if (!sel || (Array.isArray(sel) && sel.length===0)) {
      const guess = window.currentSymbol || window.lastSymbol || 'ES';
      sel = Array.isArray(guess) ? guess : [guess];
    }
    return sel;
  };

  // Delegate clicks on any [data-tf] buttons. Run after the app's handler.
  document.addEventListener('click', (ev)=>{
    const btn = ev.target.closest('[data-tf]');
    if (!btn) return;
    setTimeout(()=>{
      const navId = getActiveNavId();
      const syms = getSymbols();
      if (/nav-trend/.test(navId) && typeof window.buildTrend === 'function') {
        safe(()=>window.buildTrend(syms));
      } else if (/nav-risk/.test(navId) && typeof window.buildRisk === 'function') {
        safe(()=>window.buildRisk(syms));
      }
    }, 0);
  }, true);
})();
</script>


<script>
(()=>{
  const reapplyMarker = ()=>{
    try{
      if (typeof window.updateCandleMarker === 'function') { updateCandleMarker(); return; }
      if (typeof window.positionCandleMarker === 'function') { positionCandleMarker(); return; }
      if (typeof window.refreshMarker === 'function') { refreshMarker(); return; }
    }catch(_){}
  };
  document.addEventListener('risk:rendered', reapplyMarker);
  document.addEventListener('trend:rendered', reapplyMarker);
  // Fallback: after our forced rebuilds, try once on microtask
  setTimeout(reapplyMarker, 0);
})();
</script>



<script id="chips-row-autobuild">
(()=>{
  const ensureRow = ()=>{
    let row = document.getElementById('multiSymbolTabs');
    if (!row) {
      const anchor = document.querySelector('div.card') || document.body;
      row = document.createElement('div');
      row.id = 'multiSymbolTabs';
      row.className = 'tabs';
      row.setAttribute('aria-label','Open symbols');
      anchor.parentNode.insertBefore(row, anchor);
    }
    return row;
  };

  const norm = s => (s||'').toUpperCase().trim().replace(/[^A-Z0-9]/g,'').slice(0,4);
  const valid = s => /^[A-Z0-9]{1,4}$/.test(s||'');

  function addChip(sym){
    sym = norm(sym);
    if (!valid(sym)) return;
    const row = ensureRow();
    let ex = row.querySelector('.tabbtn[data-sym="'+sym+'"]');
    if (!ex){
      const b = document.createElement('button');
      b.type = 'button';
      b.className = 'tabbtn qt-chip';
      b.dataset.sym = sym;
      b.textContent = sym;
      b.addEventListener('click', ()=>{
        try { activate(sym); } catch(_) { try { reAnalyze(sym); } catch(e){} }
      }, false);
      row.insertBefore(b, row.firstChild);
      ex = b;
    }
    Array.from(row.querySelectorAll('.tabbtn')).forEach(btn=>btn.classList.toggle('active', btn===ex));
  }

  function selectedSymbolsFallback(){
    try{
      const sel = document.getElementById('futures');
      if (!sel) return [];
      const out = [];
      Array.from(sel.options).forEach(o=>{ if(o.selected){ const tok=(o.value||o.text||'').split(/[ \u2014-]/)[0].toUpperCase(); if(/^[A-Z0-9]{1,4}$/.test(tok)) out.push(tok);} });
      return Array.from(new Set(out));
    }catch(_){ return []; }
  }

  function addChipsForSelected(){
    let syms = [];
    try { if (typeof getSelectedFutures==='function') syms = getSelectedFutures() || []; } catch(_){}
    if (!Array.isArray(syms) || !syms.length) syms = selectedSymbolsFallback();
    if (Array.isArray(syms) && syms.length) syms.forEach(addChip);
  }

  // A) On futures selection change
  window.addEventListener('change', (ev)=>{
    if (ev.target && ev.target.closest && ev.target.closest('#futures')){
      setTimeout(addChipsForSelected, 0);
    }
  }, true);

  // B) On bundle click
  document.addEventListener('click', (ev)=>{
    const b = ev.target && ev.target.closest('[data-bundle]');
    if (b) setTimeout(addChipsForSelected, 60);
  }, true);

  // C) On Analyze (Risk) click
  document.addEventListener('click', (ev)=>{
    const btn = ev.target && ev.target.closest('button,.btn,[role="button"]');
    if (!btn) return;
    const txt = (btn.textContent||'').toLowerCase();
    const looksAnalyzeRisk = btn.matches('[data-action="risk"]') || (txt.includes('analyze') && txt.includes('risk'));
    if (looksAnalyzeRisk) setTimeout(addChipsForSelected, 200);
  }, true);

  // D) On Risk tab click (above risk card)
  document.addEventListener('click', (ev)=>{
    const rtab = ev.target && ev.target.closest('#riskTabBar .rtab');
    if (rtab && rtab.dataset && rtab.dataset.sym) setTimeout(()=>addChip(rtab.dataset.sym), 0);
  }, true);

  // E) First load
  window.addEventListener('load', ()=>{
    ensureRow();
    setTimeout(addChipsForSelected, 400);
  });
})();
</script>



<script id="risk-tabs-hardwire">
(()=>{
  const $ = (s, r=document)=>r.querySelector(s);
  const $$ = (s, r=document)=>Array.from(r.querySelectorAll(s));

  // Prefer existing function if present
  const rebuild = ()=>{
    try { if (typeof window.riskTabsForceRebuild==='function') return window.riskTabsForceRebuild(); } catch(_){}
    try { if (typeof window.buildTabs==='function') return window.buildTabs(window.preferSym||null); } catch(_){}
  };

  // 1) Rebuild tabs when futures selection changes
  window.addEventListener('change', (e)=>{
    const sel = e.target && e.target.closest('#futures');
    if (sel) setTimeout(rebuild, 50);
  }, true);

  // 2) Rebuild after clicking a bundle
  document.addEventListener('click', (e)=>{
    const btn = e.target && e.target.closest('[data-bundle]');
    if (btn) setTimeout(rebuild, 120);
  }, true);

  // 3) Robust Analyze (Risk) detection using closest()
  document.addEventListener('click', (e)=>{
    const btn = e.target && e.target.closest('button,.btn,[role="button"]');
    if (!btn) return;
    const txt = (btn.textContent||'').toLowerCase();
    const looksAnalyzeRisk = btn.matches('[data-action="risk"]')
                           || (txt.includes('analyze') && txt.includes('risk'));
    if (looksAnalyzeRisk){
      setTimeout(rebuild, 300);
    }
  }, true);

  // 4) Also rebuild when a pinned Risk tab is clicked (ensures bar stays in sync)
  document.addEventListener('click', (e)=>{
    const rtab = e.target && e.target.closest('#riskTabBar .rtab');
    if (rtab) setTimeout(rebuild, 0);
  }, true);

  // 5) First load safety net
  window.addEventListener('load', ()=>{
    setTimeout(rebuild, 700);
  });
})();
</script>




<script id="risk-quick-tabs">
(()=>{
  const row = document.getElementById('riskQuickTabs');
  if (!row) return;

  const LS = {
    ORDER: 'quickTabs.order',
    LAST:  'quickTabs.last',
    REFRESH: 'quickTabs.refresh'
  };

  const norm = s => (s||'').toUpperCase().trim().replace(/[^A-Z0-9]/g,'').slice(0,4);
  const valid = s => /^[A-Z0-9]{1,4}$/.test(s||'');

  let refreshTimer = null;

  function clearTimer(){
    if (refreshTimer){ try{ clearInterval(refreshTimer); }catch(_){ } refreshTimer=null; }
  }
  function startTimer(){
    clearTimer();
    const sel = row.querySelector('.qt-refresh');
    if (!sel) return;
    let v = sel.value || 'off';
    if (v === 'off') { v = '30'; sel.value = '30'; }
    localStorage.setItem(LS.REFRESH, v);
    const n = parseInt(v, 10);
    const ms = Number.isFinite(n) ? n*1000 : 0; // supports 15/30/60/120/etc
    if (!ms) return;
    refreshTimer = setInterval(()=>{
      const active = row.querySelector('.tabbtn.active');
      const sym = active && active.dataset.sym;
      if (!sym) return;
      try{ if (typeof selectInDOM==='function') selectInDOM(sym); }catch(_){}
      try{ if (typeof window.buildRisk==='function') window.buildRisk([sym]); }catch(_){}
    }, ms);
  }

  function ensureControls(){
    let ctl = row.querySelector('.qt-controls');
    if (ctl) return ctl;
    ctl = document.createElement('div');
    ctl.className = 'qt-controls';

    // Add-symbol UI
    const add = document.createElement('div');
    add.className = 'qt-add';
    const inp = document.createElement('input');
    inp.type = 'text'; inp.placeholder = 'SYM'; inp.maxLength = 4;
    const btn = document.createElement('button');
    btn.type = 'button'; btn.textContent = '+ Add';
    btn.addEventListener('click', ()=>{
      const s = norm(inp.value);
      if (!valid(s)) { inp.focus(); return; }
      ensureChip(s);
      activateChip(s);
      inp.value='';
    }, false);
    inp.addEventListener('keydown', (e)=>{ if (e.key==='Enter'){ e.preventDefault(); btn.click(); } });
    add.appendChild(inp); add.appendChild(btn);

    // Refresh dropdown (dynamic; includes 15s option)
    const sel = document.createElement('select');
    sel.className = 'qt-refresh';
    sel.innerHTML = ''
      + '<option value="off">Auto-refresh: Off</option>'
      + '<option value="15">Every 15s</option>'
      + '<option value="30">Every 30s</option>'
      + '<option value="60">Every 60s</option>'
      + '<option value="120">Every 120s</option>';
    let saved = localStorage.getItem(LS.REFRESH);
    if (!saved || saved === 'off') saved = '30';
    sel.value = saved;
    sel.addEventListener('change', startTimer, false);

    ctl.appendChild(add);
    ctl.appendChild(sel);
    row.appendChild(ctl);
    // Clear button
    const clr = document.createElement('button');
    clr.type='button'; clr.className='qt-clear'; clr.textContent='Clear selected'; clr.title='Remove the active chip';
    clr.addEventListener('click', (e)=>{  const active = row.querySelector('.tabbtn.active');  if (!active) return;  active.remove();  try{ localStorage.removeItem(LS.LAST); }catch(_){ }  try{ saveOrder(); }catch(_){ }  markActive(null);}, false);
    ctl.insertBefore(clr, sel);

    // Start timer per saved preference
    startTimer();
    return ctl;
  }

  function selectedSymbolsFallback(){
    try{
      const sel = document.getElementById('futures');
      if (!sel) return [];
      const out = [];
      Array.from(sel.options).forEach(o=>{
        if (o.selected){
          const tok=(o.value||o.text||o.innerText||'').split(/[ \u2014-]/)[0];
          const n = norm(tok); if (n) out.push(n);
        }
      });
      return Array.from(new Set(out));
    }catch(_){ return []; }
  }
  function getSyms(){
    try { if (typeof getSelectedFutures==='function') { const a=getSelectedFutures(); if (Array.isArray(a)&&a.length) return Array.from(new Set(a.map(norm).filter(valid))); } } catch(_){}
    return selectedSymbolsFallback();
  }

  function markActive(sym){
    Array.from(row.querySelectorAll('.tabbtn')).forEach(b=>b.classList.toggle('active', b.dataset.sym===sym));
    if (sym) localStorage.setItem(LS.LAST, sym);
    startTimer(); // maintain refresh for current active
  }

  function activateChip(sym){
    try{ if (typeof selectInDOM==='function') selectInDOM(sym); }catch(_){}
    try{ if (typeof window.buildRisk==='function') window.buildRisk([sym]); }catch(_){}
    markActive(sym);
  }

  function ensureChip(sym){
    sym = norm(sym);
    if (!valid(sym)) return null;
    let b = row.querySelector('.tabbtn[data-sym="'+sym+'"]');
    if (!b){
      b = document.createElement('button');
      b.type='button'; b.className = 'tabbtn qt-chip'; b.dataset.sym=sym; b.textContent=sym;
      b.setAttribute('draggable','true');
      b.addEventListener('click', ()=>activateChip(sym), false);
      b.addEventListener('auxclick', (e)=>{ if (e.button===1){ e.preventDefault(); b.remove(); saveOrder(); } }, false);
      // Drag reorder
      b.addEventListener('dragstart', (e)=>{ e.dataTransfer.setData('text/plain', sym); e.dataTransfer.effectAllowed='move'; }, false);
      b.addEventListener('dragover', (e)=>{ e.preventDefault(); e.dataTransfer.dropEffect='move'; }, false);
      b.addEventListener('drop', (e)=>{
        e.preventDefault();
        const src = e.dataTransfer.getData('text/plain');
        if (!src || src===sym) return;
        const srcBtn = row.querySelector('.tabbtn[data-sym="'+src+'"]');
        if (!srcBtn) return;
        const rect = b.getBoundingClientRect();
        if (e.clientX < rect.left + rect.width/2){ row.insertBefore(srcBtn, b); } else { row.insertBefore(srcBtn, b.nextSibling); }
        saveOrder();
      }, false);
      row.insertBefore(b, row.querySelector('.qt-controls') || null);
    }
    return b;
  }

  function currentOrder(){
    return Array.from(row.querySelectorAll('.tabbtn')).map(b=>b.dataset.sym);
  }
  function saveOrder(){
    localStorage.setItem(LS.ORDER, JSON.stringify(currentOrder()));
  }
  function applySavedOrder(){
    try{
      const raw = localStorage.getItem(LS.ORDER); if (!raw) return;
      const desired = JSON.parse(raw); if (!Array.isArray(desired)) return;
      desired.forEach(sym=>{
        const b = row.querySelector('.tabbtn[data-sym="'+sym+'"]');
        if (b) row.insertBefore(b, row.querySelector('.qt-controls') || null);
      });
    }catch(_){}
  }

  function rebuildChips(prefer=null){
    ensureControls();
    const syms = getSyms();
    syms.forEach(ensureChip);
    applySavedOrder();
    const last = prefer || localStorage.getItem(LS.LAST) || (syms[0]||null);
    if (last){
      ensureChip(last);
      markActive(last);
    }
  }

  // Wire to Analyze (Risk)
  document.addEventListener('click', (ev)=>{
    const btn = ev.target && ev.target.closest('button,.btn,[role="button"]');
    if (!btn) return;
    const txt = (btn.textContent||'').toLowerCase();
    const looksAnalyzeRisk = btn.matches('[data-action="risk"]') || (txt.includes('analyze') && txt.includes('risk'));
    if (looksAnalyzeRisk) setTimeout(()=>rebuildChips(), 250);
  }, true);

  // Also rebuild when selection changes or bundles clicked
  window.addEventListener('change', (ev)=>{
    if (ev.target && ev.target.closest && ev.target.closest('#futures')) setTimeout(()=>rebuildChips(), 0);
  }, true);
  document.addEventListener('click', (ev)=>{
    const b = ev.target && ev.target.closest('[data-bundle]'); if (b) setTimeout(()=>rebuildChips(), 80);
  }, true);

  // Keyboard: Ctrl+Left/Right to cycle chips
  document.addEventListener('keydown', (e)=>{
    if (!(e.ctrlKey || e.metaKey)) return;
    if (e.key!=='ArrowLeft' && e.key!=='ArrowRight') return;
    const chips = Array.from(row.querySelectorAll('.tabbtn'));
    if (!chips.length) return;
    const active = row.querySelector('.tabbtn.active');
    const idx = Math.max(0, chips.indexOf(active));
    e.preventDefault();
    const next = e.key==='ArrowLeft' ? (idx-1+chips.length)%chips.length : (idx+1)%chips.length;
    chips[next].click();
  }, true);

  // First load
  window.addEventListener('load', ()=>setTimeout(()=>rebuildChips(), 600));
})();
</script>




<script id="slider-label-fix">
(()=>{
  function placeLabelRight(){
    try{
      const slider = document.getElementById('riskCandles');
      const label  = document.getElementById('riskCandlesLabel');
      if (!slider || !label) return;
      // Ensure label sits after slider and parent lays out horizontally
      const parent = slider.parentElement || slider.closest('div,section') || document.body;
      if (label.previousElementSibling !== slider){
        slider.after(label);
      }
      parent.style.display = 'flex';
      parent.style.alignItems = 'center';
      parent.style.gap = '8px';
      // Stop any previous absolute positioning
      label.style.left = 'auto';
      label.style.top = 'auto';
      label.style.transform = 'none';
      label.style.position = 'static';
    }catch(_){}
  }

  // Override bubble updater to only set text (no positioning)
  const safeOverride = ()=>{
    try{
      const prev = window.updateSliderBubble;
      window.updateSliderBubble = function(){
        try{
          const slider = document.getElementById('riskCandles');
          const label  = document.getElementById('riskCandlesLabel');
          if (!slider || !label) return;
          const v = parseInt(slider.value,10);
          label.textContent = (v||0) + (v===1?' candle':' candles');
          // keep static
          label.style.left='auto'; label.style.top='auto'; label.style.transform='none'; label.style.position='static';
        }catch(_){}
      };
    }catch(_){}
  };

  window.addEventListener('load', ()=>{ placeLabelRight(); safeOverride(); setTimeout(()=>{ try{window.updateSliderBubble&&window.updateSliderBubble();}catch(_){} }, 0); });
  window.addEventListener('resize', ()=>{ try{window.updateSliderBubble&&window.updateSliderBubble();}catch(_){} });
  document.addEventListener('input', (e)=>{ if (e && e.target && e.target.id==='riskCandles'){ try{ window.updateSliderBubble&&window.updateSliderBubble(); }catch(_){} } }, true);
})();
</script>


<script>
window.addEventListener('load', function(){
  try{
    var akW = document.getElementById('chipAKWrap');
    var akAll = document.getElementById('chipAKAll');
    if (akW && akAll && !akW.querySelector('.tag')){
      var t=document.createElement('span'); t.className='tag'; t.textContent='AK';
      akW.insertBefore(t, akAll);
    }
    var bgW = document.getElementById('chipBGWrap');
    var bgAll = document.getElementById('chipBGAll');
    if (bgW && bgAll && !bgW.querySelector('.tag')){
      var t2=document.createElement('span'); t2.className='tag'; t2.textContent='BG';
      bgW.insertBefore(t2, bgAll);
    }
  }catch(_){}
});
</script>


<script id="qt-chip-cleanup">
window.addEventListener('load', function(){
  try{
    var row = document.getElementById('riskQuickTabs');
    if (!row) return;
    document.querySelectorAll('.qt-chip').forEach(function(el){
      if (!row.contains(el)) el.remove();
    });
  }catch(_){}
});
</script>

</body>
</html>
